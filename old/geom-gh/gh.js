// Generated by CoffeeScript 1.6.2
var __slice = [].slice;

define(function(require) {
  var GeomExtensions, LineBuilder, PI, Plane, Spline3D, Vec2, Vec3, abs, cos, gh, max, min, sin, _ref;

  GeomExtensions = require('geom/Extensions');
  _ref = require('pex/geom'), Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Spline3D = _ref.Spline3D;
  Plane = require('geom/Plane');
  LineBuilder = require('pex/geom/gen').LineBuilder;
  PI = Math.PI, sin = Math.sin, cos = Math.cos, min = Math.min, max = Math.max, abs = Math.abs;
  gh = {};
  gh.type = function(o) {
    return Object.prototype.toString.call(o);
  };
  gh.isList = function(o) {
    return gh.type(o) === '[object Array]';
  };
  gh.isTree = function(o) {
    return gh.isList(o[0]);
  };
  gh.isValue = function(o) {
    return !gh.isList(o) && !gh.isTree(o);
  };
  gh.isNumber = function(o) {
    return gh.type(o) === '[object Number]';
  };
  gh.list = function(o) {
    if (gh.isList(o)) {
      return o;
    } else {
      return [o];
    }
  };
  gh.listPaths = function(o) {
    var listBranches, paths, stack;

    if (gh.isValue(o)) {
      return [[0]];
    }
    if (gh.isList(o) && !gh.isTree(o)) {
      return [[0]];
    }
    paths = [];
    stack = [0];
    listBranches = function(root) {
      if (gh.isValue(root)) {
        paths.push(stack);
        return;
      }
      return root.forEach(function(branch, branchIndex) {
        stack.push(branchIndex);
        if (gh.isTree(branch)) {
          listBranches(branch, branchIndex);
        } else {
          paths.push(stack.map(function(v) {
            return v;
          }));
        }
        return stack.pop();
      });
    };
    listBranches(o);
    return paths;
  };
  gh.listList = function(o) {
    if (gh.isList(o[0])) {
      return o;
    } else {
      return [o];
    }
  };
  gh.xvec = function(x) {
    return gh.dataMatching(x, function(x) {
      return new Vec3(x, 0, 0);
    });
  };
  gh.yvec = function(y) {
    return gh.dataMatching(y, function(y) {
      return new Vec3(0, y, 0);
    });
  };
  gh.zvec = function(z) {
    return gh.dataMatching(z, function(z) {
      return new Vec3(0, 0, z);
    });
  };
  gh.interval = function(t0, t1) {
    var intervale;

    return intervale = {
      t0: t0,
      t1: t1,
      min: min(t0, t1),
      max: max(t0, t1),
      range: max(t0, t1) - min(t0, t1)
    };
  };
  gh.line = function(from, to) {
    var line;

    return line = {
      closed: false,
      from: from,
      to: to,
      pointAt: function(t) {
        return Vec3.create().asInterpolated(this.from, this.to, t);
      }
    };
  };
  gh.polyline = function(points, closed) {
    var polyline;

    if (closed == null) {
      closed = false;
    }
    return polyline = {
      closed: closed,
      points: points,
      pointAt: function(t) {
        return this.points[floor(t * (this.points.length - 1))];
      },
      clone: function() {
        var pointsCopy;

        pointsCopy = this.points.map(function(p) {
          return p.dup();
        });
        polyline = gh.polyline(pointsCopy);
        polyline.closed = polyline.closed;
        return polyline;
      }
    };
  };
  gh.spline = function(points) {
    return new Spline3D(points);
  };
  gh.maxLen = function(values, valueTypes) {
    var lengths;

    lengths = values.map(function(value, valueIndex) {
      if (gh.isList(value)) {
        if (valueTypes[valueIndex] === 'LIST') {
          return 1;
        } else {
          return value.length;
        }
      } else {
        return 1;
      }
    });
    return lengths.reduce(function(a, b) {
      return Math.max(a, b);
    });
  };
  gh.offsetRandom = function(point, r) {
    return gh.dataMatching(point, r, function(point, r) {
      var np;

      np = point.dup();
      np.x += 2 * (MathUtils.randomFloat() - 0.5) * r;
      np.y += 2 * (MathUtils.randomFloat() - 0.5) * r;
      np.z += 2 * (MathUtils.randomFloat() - 0.5) * r;
      return np;
    });
  };
  gh.point = function(x, y, z) {
    return new Vec3(x, y, z);
  };
  gh.vector = gh.point;
  gh.plane = function(point, normal) {
    return new Plane(point, normal);
  };
  gh.circle = function(center, r) {
    var circle, plane;

    if (r == null) {
      r = 1;
    }
    plane = null;
    if (!isNaN(center.x) && !isNaN(center.y) && !isNaN(center.z) && center.length) {
      plane = new Plane(center);
    } else if (center.point && center.normal) {
      plane = center;
    } else {
      throw 'gh.circle center needs to be Point or Plane';
    }
    return circle = {
      plane: plane,
      r: r,
      closed: true,
      pointAt: function(t) {
        return plane.vec2ToVec3(new Vec2(r * cos(t * PI * 2), r * sin(t * PI * 2)));
      },
      clone: function() {}
    };
  };
  gh.makeLine = function(from, to) {
    return gh.dataMatching(from, to, function(from, to) {
      return gh.line(from, to);
    });
  };
  gh.makePolyline = function(points, closed) {
    if (closed == null) {
      closed = false;
    }
    return gh.dataMatching({
      LIST: points
    }, function(points) {
      return gh.polyline(points, closed);
    });
  };
  gh.makeSpline = function(points) {
    return gh.dataMatching({
      LIST: points
    }, function(points) {
      return gh.spline(points);
    });
  };
  gh.splitPolylineSegments = function(polyline) {
    return gh.dataMatching(polyline, function(polyline) {
      var i, segments;

      segments = (function() {
        var _i, _ref1, _results;

        _results = [];
        for (i = _i = 0, _ref1 = polyline.points.length - 1; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _results.push(gh.line(polyline.points[i], polyline.points[i + 1]));
        }
        return _results;
      })();
      if (polyline.closed) {
        segments.push(gh.line(polyline.points[polyline.points.length - 1], polyline.points[0]));
      }
      return segments;
    });
  };
  gh.series = function(start, end) {
    var _i, _results;

    return (function() {
      _results = [];
      for (var _i = start; start <= end ? _i <= end : _i >= end; start <= end ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
  };
  gh.bakePoints = function() {
    var lineBuilder, point, pointListSet, s, _i, _len;

    pointListSet = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    lineBuilder = new LineBuilder();
    s = 0.1;
    for (_i = 0, _len = pointListSet.length; _i < _len; _i++) {
      point = pointListSet[_i];
      gh.dataMatching(point, function(point) {
        lineBuilder.addLine(point.dup().add(new Vec3(-s, 0, 0)), point.dup().add(new Vec3(s, 0, 0)));
        lineBuilder.addLine(point.dup().add(new Vec3(0, -s, 0)), point.dup().add(new Vec3(0, s, 0)));
        return lineBuilder.addLine(point.dup().add(new Vec3(0, 0, -s)), point.dup().add(new Vec3(0, 0, s)));
      });
    }
    return lineBuilder;
  };
  gh.bakeLines = function() {
    var line, lineBuilder, lineListSet, _i, _len;

    lineListSet = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    lineBuilder = new LineBuilder();
    for (_i = 0, _len = lineListSet.length; _i < _len; _i++) {
      line = lineListSet[_i];
      gh.dataMatching(line, function(line) {
        return lineBuilder.addLine(line.from, line.to);
      });
    }
    return lineBuilder;
  };
  gh.getBranch = function(tree, path) {
    var key, keys;

    keys = path.map(function(p) {
      return p;
    });
    keys.shift();
    while (keys.length > 0) {
      key = keys.shift();
      tree = tree[key];
    }
    return tree;
  };
  gh.dataMatching = function() {
    var currentInputs, f, i, inputInfos, inputTrees, inputTypes, inputValues, inputs, maxLength, pathResults, paths, result, _i;

    inputInfos = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), f = arguments[_i++];
    inputs = inputInfos.map(function(input) {
      if (input.LIST) {
        return input.LIST;
      } else {
        return input;
      }
    });
    inputTypes = inputInfos.map(function(input) {
      if (input.LIST) {
        return 'LIST';
      } else {
        return 'VALUE';
      }
    });
    inputTrees = inputs.filter(function(input) {
      return gh.isTree(input);
    });
    if (inputTrees.length === 0) {
      currentInputs = inputs;
      maxLength = gh.maxLen(currentInputs, inputTypes);
      result = (function() {
        var _j, _results;

        _results = [];
        for (i = _j = 0; 0 <= maxLength ? _j < maxLength : _j > maxLength; i = 0 <= maxLength ? ++_j : --_j) {
          inputValues = currentInputs.map(function(input, inputIndex) {
            if (gh.isList(input)) {
              return input[i % input.length];
            } else {
              return input;
            }
          });
          _results.push(f.apply(null, inputValues));
        }
        return _results;
      })();
      return result;
    } else if (inputTrees.length === 1) {
      paths = gh.listPaths(inputTrees[0]);
      pathResults = paths.map(function(path) {
        currentInputs = inputs.map(function(input) {
          if (gh.isTree(input)) {
            return gh.getBranch(input, path);
          } else if (gh.isList(input)) {
            return input;
          } else {
            return input;
          }
        });
        maxLength = gh.maxLen(currentInputs, inputTypes);
        result = (function() {
          var _j, _results;

          _results = [];
          for (i = _j = 0; 0 <= maxLength ? _j < maxLength : _j > maxLength; i = 0 <= maxLength ? ++_j : --_j) {
            inputValues = currentInputs.map(function(input, inputIndex) {
              if (gh.isList(input)) {
                if (inputTypes[inputIndex] === 'LIST') {
                  return input;
                } else {
                  return input[i % input.length];
                }
              } else {
                return input;
              }
            });
            _results.push(f.apply(null, inputValues));
          }
          return _results;
        })();
        return result;
      });
      return pathResults;
    } else {
      return 'throw unupported data to match';
    }
  };
  gh.random = function(n, domain, seed) {
    var i, _i, _results;

    if (n == null) {
      n = 1;
    }
    if (domain == null) {
      domain = gh.interval(0, 1);
    }
    _results = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      _results.push(domain.min + domain.range * random());
    }
    return _results;
  };
  gh.randomPoint = function(n, domain, seed, normalize) {
    var x, y, z;

    if (n == null) {
      n = 1;
    }
    if (domain == null) {
      domain = gh.interval(-1, 1);
    }
    if (normalize == null) {
      normalize = true;
    }
    x = gh.random(n, domain, seed);
    y = gh.random(n, domain, seed);
    z = gh.random(n, domain, seed);
    return gh.makePoint(x, y, z);
  };
  gh.makePoint = function(x, y, z) {
    return gh.dataMatching(x, y, z, function(x, y, z) {
      return new Vec3(x, y, z);
    });
  };
  gh.normalize = function(point) {
    return gh.dataMatching(point, function(point) {
      return point.dup().normalize();
    });
  };
  gh.move = function(point, offset) {
    if (offset == null) {
      offset = gh.point(0, 0, 0);
    }
    return gh.dataMatching(point, offset, function(point, offset) {
      return point.dup().add(offset);
    });
  };
  gh.add = gh.move;
  gh.divide = function(curve, n) {
    if (!curve.closed) {
      n = n + 1;
    }
    return gh.dataMatching(curve, n, function(curve, n) {
      var i, numSegments, points, _i;

      numSegments = curve.closed ? n : max(1, n - 1);
      points = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        points.push(curve.pointAt(i / numSegments));
      }
      return points;
    });
  };
  gh.divideToTangents = function(curve, n) {
    n = n + 1;
    return gh.dataMatching(curve, n, function(curve, n) {
      var i, np, numSegments, p, points, _i;

      numSegments = curve.closed ? n : max(1, n - 1);
      points = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        p = curve.pointAt(i / numSegments);
        if (i / numSegments > 0.99999) {
          np = curve.pointAt(i / numSegments - 0.5 / numSegments);
          points.push(p.sub(np).normalize());
        } else {
          np = curve.pointAt(i / numSegments + 0.5 / numSegments);
          points.push(np.sub(p).normalize());
        }
      }
      return points;
    });
  };
  gh.flatten = function(tree) {
    var branch, path, result, _i, _len, _ref1;

    result = [];
    _ref1 = gh.listPaths(tree);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      path = _ref1[_i];
      branch = gh.getBranch(tree, path);
      result = result.concat(branch);
    }
    return result;
  };
  gh.replace = function(tree, value) {
    return gh.dataMatching(tree, value, function(tree, value) {
      return value;
    });
  };
  gh.rotate = function(point, axis, angle) {
    return gh.dataMatching(point, axis, angle, function(point, axis, angle) {
      var line, p, pointCopy, _i, _len, _ref1;

      if (point.points) {
        pointCopy = point.clone();
        _ref1 = pointCopy.points;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          p = _ref1[_i];
          p.transformQuat(Quat.create().setAxisAngle(axis, angle));
        }
        return pointCopy;
      } else if (point.from && point.to) {
        line = point;
        return gh.line(line.from.dup().transformQuat(Quat.create().setAxisAngle(axis, angle)), line.to.dup().transformQuat(Quat.create().setAxisAngle(axis, angle)));
      } else {
        return point.dup().transformQuat(Quat.create().setAxisAngle(axis, angle));
      }
    });
  };
  gh.mul = function(a, b) {
    return gh.dataMatching(a, b, function(a, b) {
      return a * b;
    });
  };
  return gh;
});

/*
//@ sourceMappingURL=gh.map
*/
