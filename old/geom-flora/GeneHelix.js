// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Color, Cube, GeneHelix, Mesh, PI, Quat, SolidColor, Time, UP, Vec3, cos, floor, random, sin, _ref;

  _ref = require('pex/geom'), Vec3 = _ref.Vec3, Quat = _ref.Quat;
  Cube = require('pex/geom/gen').Cube;
  SolidColor = require('pex/materials').SolidColor;
  Mesh = require('pex/gl').Mesh;
  Time = require('pex/utils').Time;
  Color = require('pex/color').Color;
  sin = Math.sin, cos = Math.cos, floor = Math.floor, random = Math.random, PI = Math.PI;
  UP = new Vec3(0, 1, 0);
  return GeneHelix = (function() {
    function GeneHelix() {
      var bridgeScale, geom, i, nPerHelix, scale, _i, _j, _ref1, _ref2;

      geom = new Cube(1, 1, 1);
      geom.computeEdges();
      this.active = false;
      this["static"] = false;
      this.visible = true;
      this.localRotation = random() * PI * 2;
      this.rotation = 0;
      this.targetRotation = 0;
      this.aminoacidColor = new Color(0.2, 1.0, 0.8, 1.0);
      this.activeMaterial = new SolidColor({
        color: new Color(1, 1, 1, 1)
      });
      this.inactiveMaterial = new SolidColor({
        color: Color.Yellow
      });
      this.mesh = new Mesh(geom, this.inactiveMaterial, {
        useEdges: true
      });
      this.aminoacid = new Mesh(geom, new SolidColor({
        color: this.aminoacidColor
      }));
      this.bridge = new Mesh(geom, new SolidColor({
        color: this.aminoacidColor
      }));
      this.targetPosition = new Vec3(0, 0, 0);
      this.aminoInstances = [];
      nPerHelix = 18;
      scale = new Vec3(0.025, 0.025, 0.025);
      this.positionRange = 0.25;
      for (i = _i = 0, _ref1 = nPerHelix - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        this.aminoInstances.push({
          scale: scale,
          position: new Vec3(0, 0, 0)
        });
        this.aminoInstances.push({
          scale: scale,
          position: new Vec3(0, 0, 0)
        });
      }
      this.bridgeInstances = [];
      bridgeScale = new Vec3(0.5, 0.005, 0.005);
      for (i = _j = 0, _ref2 = nPerHelix - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
        this.bridgeInstances.push({
          scale: bridgeScale,
          position: new Vec3(0, 0, 0),
          rotation: new Quat().setAxisAngle(UP, 800 * Math.random())
        });
      }
    }

    GeneHelix.prototype.setActive = function(state) {
      this.active = state;
      if (this.active) {
        return this.mesh.setMaterial(this.activeMaterial);
      }
    };

    GeneHelix.prototype.setStatic = function(state) {
      return this["static"] = state;
    };

    GeneHelix.prototype.setVisible = function(state) {
      return this.visible = state;
    };

    GeneHelix.prototype.draw = function(camera) {
      var k,
        _this = this;

      if (!this.visible) {
        return;
      }
      this.rotationSpeed = 0.5;
      if (!this.active) {
        this.rotationSpeed = 0;
      }
      this.rotation += (this.targetRotation - this.rotation) * 0.1;
      this.aminoInstances.forEach(function(inst, instIndex) {
        var anlgeOffset, t;

        t = floor(instIndex / 2) / floor(_this.aminoInstances.length / 2);
        anlgeOffset = instIndex % 2 === 0 ? 0 : PI;
        return inst.position.set(_this.mesh.position.x + _this.positionRange * cos(_this.localRotation + anlgeOffset + t * 2 * PI + Time.seconds * 4 * _this.rotationSpeed), _this.mesh.position.y + t - 0.5, _this.mesh.position.z + _this.positionRange * sin(_this.localRotation + anlgeOffset + t * 2 * PI + Time.seconds * 4 * _this.rotationSpeed));
      });
      this.bridgeInstances.forEach(function(inst, instIndex) {
        var t;

        t = instIndex / _this.bridgeInstances.length;
        inst.position.set(_this.mesh.position.x, _this.mesh.position.y + t - 0.5, _this.mesh.position.z);
        return inst.rotation.setAxisAngle(new Vec3(0, 1, 0), -_this.localRotation / PI * 180 - 4 * Time.seconds / PI * 180 * _this.rotationSpeed - 360 * t + 180);
      });
      k = ((this.rotation % (2 * PI)) + 2 * PI) % (2 * PI) / (2 * PI);
      if (k !== 0) {
        this.aminoacidColor.setHSV(k, 0.5, 1);
      }
      if (!this["static"]) {
        this.mesh.draw(camera);
      }
      this.mesh.rotation.setAxisAngle(new Vec3(0, 1, 0), 180 / PI * this.rotation);
      this.aminoacid.drawInstances(camera, this.aminoInstances);
      return this.bridge.drawInstances(camera, this.bridgeInstances);
    };

    return GeneHelix;

  })();
});

/*
//@ sourceMappingURL=GeneHelix.map
*/
