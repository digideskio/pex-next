// Generated by CoffeeScript 1.6.2
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(function(require) {
  var Color, Config, Context, Cube, Diffuse, Mesh, SolidColor, ValueRange, Vec3, Voxels, abs, max, min, mix, randomFloat, _ref, _ref1, _ref2;

  Cube = require('pex/geom/gen').Cube;
  _ref = require('pex/gl'), Mesh = _ref.Mesh, Context = _ref.Context;
  _ref1 = require('pex/materials'), SolidColor = _ref1.SolidColor, Diffuse = _ref1.Diffuse;
  Vec3 = require('pex/geom').Vec3;
  Color = require('pex/color').Color;
  min = Math.min, max = Math.max, abs = Math.abs;
  _ref2 = require('pex/utils/MathUtils'), mix = _ref2.mix, randomFloat = _ref2.randomFloat;
  Config = require('flora/game/Config');
  ValueRange = (function() {
    function ValueRange(name) {
      this.name = name;
    }

    ValueRange.prototype.start = function() {
      this.min = null;
      return this.max = null;
    };

    ValueRange.prototype.add = function(v) {
      if (v < this.min || this.min === null) {
        this.min = v;
      }
      if (v > this.max || this.max === null) {
        return this.max = v;
      }
    };

    ValueRange.prototype.toString = function() {
      return "" + this.name + " min:" + this.min + " max:" + this.max;
    };

    return ValueRange;

  })();
  return Voxels = (function(_super) {
    __extends(Voxels, _super);

    function Voxels(nu, nv) {
      var cubeGeom, u, v, x, z, _i, _j;

      this.gl = Context.currentContext.gl;
      this.size = min(1 / nu, 1 / nv);
      this.ratio = nu / nv;
      cubeGeom = new Cube(1, 1, 1);
      cubeGeom.computeEdges();
      this.fillMaterial = new Diffuse({
        diffuseColor: Color.Black,
        wrap: 2
      });
      this.edgesMaterial = new SolidColor({
        color: Config.colors.gold
      });
      this.cubeMeshFill = new Mesh(cubeGeom, this.fillMaterial);
      this.cubeWireframeMesh = new Mesh(cubeGeom, this.edgesMaterial, {
        useEdges: true
      });
      this.wireframe = 0;
      this.targetWireframe = 0;
      this.time = 0;
      this.height = 0;
      this.targetHeight = 0;
      this.levelOffset = 0;
      this.instances = [];
      for (z = _i = 0; 0 <= nv ? _i < nv : _i > nv; z = 0 <= nv ? ++_i : --_i) {
        for (x = _j = 0; 0 <= nu ? _j < nu : _j > nu; x = 0 <= nu ? ++_j : --_j) {
          u = (x / nu - 0.5) * this.ratio;
          v = z / nv - 0.5;
          this.instances.push({
            position: new Vec3(u, 0, v),
            scale: new Vec3(this.size, this.size, this.size),
            uniforms: {
              ambientColor: new Color(0, 0, 0, 1),
              diffuseColor: new Color(0, 0, 0, 1)
            }
          });
        }
      }
      this.range = new ValueRange('y');
      Voxels.__super__.constructor.call(this, cubeGeom, this.edgesMaterial, {
        useEdges: true
      });
    }

    Voxels.prototype.setWireframe = function(state) {
      return this.targetWireframe = state ? 1 : 0;
    };

    Voxels.prototype.setHeight = function(state) {
      return this.targetHeight = state;
    };

    Voxels.prototype.update = function(surface, dt) {
      var from, height, i, instance, k, steps, to, v, y, _i, _j, _k, _len, _ref3, _ref4, _results;

      if (dt == null) {
        dt = 0;
      }
      this.time += dt * (this.wireframe * this.wireframe);
      this.wireframe += (this.targetWireframe - this.wireframe) * 0.1;
      this.height += (this.targetHeight - this.height) * 0.2;
      if (this.targetHeight === 0 && this.height < 0.01) {
        this.height = 0;
        this.levelOffset = randomFloat(-0.01, 0.03);
      }
      this.range.start();
      _ref3 = this.instances;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        instance = _ref3[_i];
        y = 0;
        for (i = _j = 1; _j <= 4; i = ++_j) {
          v = 1 / i * surface["eval"]((instance.position.x + 0.5) * i, (instance.position.z + 0.5) * i, this.time);
          y += v;
        }
        y *= 0.4;
        y += 0.03;
        y += this.levelOffset;
        height = y * 1 / 0.25;
        steps = [-0.2, 0, 0.25, 0.45, 0.6, 0.7];
        from = 0;
        to = 0;
        k = -1;
        if (height < steps[0]) {
          k = 1;
          from = 0;
          to = 0;
        }
        if (height > steps[steps.length - 1]) {
          k = 1;
          from = 5;
          to = 5;
        }
        if (k === -1) {
          for (i = _k = 0, _ref4 = steps.length; 0 <= _ref4 ? _k < _ref4 : _k > _ref4; i = 0 <= _ref4 ? ++_k : --_k) {
            if (height < steps[i]) {
              from = i - 1;
              to = i;
              k = (height - steps[i - 1]) / (steps[i] - steps[i - 1]);
              break;
            }
          }
        }
        this.range.add(to);
        instance.landType = to;
        instance.uniforms.diffuseColor.r = this.wireframe * mix(Config.colorsByHeight[from].r, Config.colorsByHeight[to].r, k);
        instance.uniforms.diffuseColor.g = this.wireframe * mix(Config.colorsByHeight[from].g, Config.colorsByHeight[to].g, k);
        instance.uniforms.diffuseColor.b = this.wireframe * mix(Config.colorsByHeight[from].b, Config.colorsByHeight[to].b, k);
        instance.uniforms.ambientColor.r = this.wireframe * mix(Config.colorsByHeightSecondary[from].r, Config.colorsByHeightSecondary[to].r, k);
        instance.uniforms.ambientColor.g = this.wireframe * mix(Config.colorsByHeightSecondary[from].g, Config.colorsByHeightSecondary[to].g, k);
        instance.uniforms.ambientColor.b = this.wireframe * mix(Config.colorsByHeightSecondary[from].b, Config.colorsByHeightSecondary[to].b, k);
        y *= 0.5;
        y *= this.height;
        if (y < -0) {
          y = -0;
        }
        instance.position.y = y / 2;
        _results.push(instance.scale.y = this.size * (1 + y / this.size));
      }
      return _results;
    };

    Voxels.prototype.draw = function(camera) {
      this.gl.lineWidth(2);
      this.cubeMeshFill.drawInstances(camera, this.instances);
      this.gl.enable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
      this.edgesMaterial.uniforms.color.a = 1 - this.wireframe;
      this.cubeWireframeMesh.drawInstances(camera, this.instances);
      return this.gl.disable(this.gl.BLEND);
    };

    return Voxels;

  })(Mesh);
});

/*
//@ sourceMappingURL=Voxels.map
*/
