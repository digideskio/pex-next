// Generated by CoffeeScript 1.6.2
var __slice = [].slice;

define(function(require) {
  var Arcball, Color, Cube, Diffuse, GUI, Geometry, LineBuilder, MathUtils, Mesh, ObjWriter, Octahedron, PI, PackDepth, PerspectiveCamera, Platform, Quat, RenderTarget, Scene, ScreenImage, ShowDepth, ShowNormals, SolidColor, Sphere, Spline3D, Texture2D, Time, Vec3, Viewport, Window, abs, atan2, cos, floor, fx, gh, hem, max, min, pex, random, randomFloat, seed, settings, sin, sqrt, tmpRot, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals, PackDepth = _ref2.PackDepth;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage;
  _ref4 = pex.geom, hem = _ref4.hem, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, hem = _ref4.hem, Quat = _ref4.Quat, Spline3D = _ref4.Spline3D;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere, LineBuilder = _ref5.LineBuilder;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils, ObjWriter = _ref6.ObjWriter;
  min = Math.min, max = Math.max, cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, atan2 = Math.atan2, floor = Math.floor;
  GUI = pex.gui.GUI;
  settings = require('utils/Settings');
  randomFloat = MathUtils.randomFloat, seed = MathUtils.seed;
  fx = pex.fx;
  /*
  Data Matching:
    - shortest list
    - longest list (repeat last)
    - cross reference (multiply)
  
  Components vs Parameters
    - do vs store
  
  Curve types:
    - line
    - polyline
    - circle
    - ellipse
    - arc
    - nurbs curve
    - poly curve
  */

  Vec3.prototype.asInterpolated = function(a, b, t) {
    this.x = a.x + (b.x - a.x) * t;
    this.y = a.y + (b.y - a.y) * t;
    this.z = a.z + (b.z - a.z) * t;
    return this;
  };
  Spline3D.prototype.pointAt = function(t) {
    return this.getPointAt(t);
  };
  Quat.fromDirection = function(direction, debug) {
    var dfWScale, dir, m, q, q2, right, up;

    q = new Quat();
    dir = MathUtils.getTempVec3('dir');
    dir.copy(direction).normalize();
    up = MathUtils.getTempVec3('up');
    up.set(0, 1, 0);
    right = MathUtils.getTempVec3('right');
    right.asCross(up, dir);
    if (right.length() === 0) {
      up.set(1, 0, 0);
      right.asCross(up, dir);
    }
    up.asCross(dir, right);
    right.normalize();
    up.normalize();
    if (debug) {
      console.log('dir', dir);
    }
    if (debug) {
      console.log('up', up);
    }
    if (debug) {
      console.log('right', right);
    }
    m = MathUtils.getTempMat4('m');
    m.set4x4r(right.x, right.y, right.z, 0, up.x, up.y, up.z, 0, dir.x, dir.y, dir.z, 0, 0, 0, 0, 1);
    q = MathUtils.getTempQuat('q');
    if (1.0 + m.a11 + m.a22 + m.a33 < 0.001) {
      if (debug) {
        console.log('singularity');
      }
      dir = direction.dup();
      dir.z *= -1;
      dir.normalize();
      up.set(0, 1, 0);
      right.asCross(up, dir);
      up.asCross(dir, right);
      right.normalize();
      up.normalize();
      m = MathUtils.getTempMat4('m');
      m.set4x4r(right.x, right.y, right.z, 0, up.x, up.y, up.z, 0, dir.x, dir.y, dir.z, 0, 0, 0, 0, 1);
      q.w = Math.sqrt(1.0 + m.a11 + m.a22 + m.a33) / 2.0;
      dfWScale = q.w * 4.0;
      q.x = (m.a23 - m.a32) / dfWScale;
      q.y = (m.a31 - m.a13) / dfWScale;
      q.z = (m.a12 - m.a21) / dfWScale;
      if (debug) {
        console.log('dir', dir);
      }
      if (debug) {
        console.log('up', up);
      }
      if (debug) {
        console.log('right', right);
      }
      q2 = MathUtils.getTempQuat('q2');
      q2.setAxisAngle(new Vec3(0, 1, 0), 180);
      q2.mul(q);
      return q2;
    }
    q.w = Math.sqrt(1.0 + m.a11 + m.a22 + m.a33) / 2.0;
    dfWScale = q.w * 4.0;
    q.x = (m.a23 - m.a32) / dfWScale;
    q.y = (m.a31 - m.a13) / dfWScale;
    q.z = (m.a12 - m.a21) / dfWScale;
    return q;
  };
  tmpRot = Quat.fromDirection(new Vec3(0.0, 0.0, -1.25)).dup();
  console.log("####");
  console.log('rot', Quat.fromDirection(new Vec3(0.0, 0.8, -1), true));
  gh = {};
  gh.type = function(o) {
    return Object.prototype.toString.call(o);
  };
  gh.isList = function(o) {
    return gh.type(o) === '[object Array]';
  };
  gh.isTree = function(o) {
    return gh.isList(o[0]);
  };
  gh.isValue = function(o) {
    return !gh.isList(o) && !gh.isTree(o);
  };
  gh.isNumber = function(o) {
    return gh.type(o) === '[object Number]';
  };
  gh.list = function(o) {
    if (gh.isList(o)) {
      return o;
    } else {
      return [o];
    }
  };
  gh.listPaths = function(o) {
    var listBranches, paths, stack;

    if (gh.isValue(o)) {
      return [[0]];
    }
    if (gh.isList(o) && !gh.isTree(o)) {
      return [[0]];
    }
    paths = [];
    stack = [0];
    listBranches = function(root) {
      if (gh.isValue(root)) {
        paths.push(stack);
        return;
      }
      return root.forEach(function(branch, branchIndex) {
        stack.push(branchIndex);
        if (gh.isTree(branch)) {
          listBranches(branch, branchIndex);
        } else {
          paths.push(stack.map(function(v) {
            return v;
          }));
        }
        return stack.pop();
      });
    };
    listBranches(o);
    return paths;
  };
  gh.listList = function(o) {
    if (gh.isList(o[0])) {
      return o;
    } else {
      return [o];
    }
  };
  gh.xvec = function(x) {
    return gh.dataMatching(x, function(x) {
      return new Vec3(x, 0, 0);
    });
  };
  gh.yvec = function(y) {
    return gh.dataMatching(y, function(y) {
      return new Vec3(0, y, 0);
    });
  };
  gh.zvec = function(z) {
    return gh.dataMatching(z, function(z) {
      return new Vec3(0, 0, z);
    });
  };
  gh.interval = function(t0, t1) {
    var intervale;

    return intervale = {
      t0: t0,
      t1: t1,
      min: min(t0, t1),
      max: max(t0, t1),
      range: max(t0, t1) - min(t0, t1)
    };
  };
  gh.line = function(from, to) {
    var line;

    return line = {
      closed: false,
      from: from,
      to: to,
      pointAt: function(t) {
        return Vec3.create().asInterpolated(this.from, this.to, t);
      }
    };
  };
  gh.polyline = function(points) {
    var polyline;

    return polyline = {
      closed: false,
      points: points,
      pointAt: function(t) {
        return this.points[floor(t * (this.points.length - 1))];
      },
      clone: function() {
        var pointsCopy;

        pointsCopy = this.points.map(function(p) {
          return p.dup();
        });
        polyline = gh.polyline(pointsCopy);
        polyline.closed = polyline.closed;
        return polyline;
      }
    };
  };
  gh.spline = function(points) {
    return new Spline3D(points);
  };
  gh.maxLen = function(values, valueTypes) {
    var lengths;

    lengths = values.map(function(value, valueIndex) {
      if (gh.isList(value)) {
        if (valueTypes[valueIndex] === 'LIST') {
          return 1;
        } else {
          return value.length;
        }
      } else {
        return 1;
      }
    });
    return lengths.reduce(function(a, b) {
      return Math.max(a, b);
    });
  };
  gh.offsetRandom = function(point, r) {
    return gh.dataMatching(point, r, function(point, r) {
      var np;

      np = point.dup();
      np.x += 2 * (MathUtils.randomFloat() - 0.5) * r;
      np.y += 2 * (MathUtils.randomFloat() - 0.5) * r;
      np.z += 2 * (MathUtils.randomFloat() - 0.5) * r;
      return np;
    });
  };
  gh.point = function(x, y, z) {
    return new Vec3(x, y, z);
  };
  gh.vector = gh.point;
  gh.circle = function(center, r) {
    var circle;

    if (center == null) {
      center = gh.point(0, 0, 0);
    }
    if (r == null) {
      r = 1;
    }
    return circle = {
      center: center,
      r: r,
      closed: true,
      pointAt: function(t) {
        return new Vec3(r * cos(t * PI * 2), 0, r * sin(t * PI * 2));
      },
      clone: function() {}
    };
  };
  gh.makeLine = function(from, to) {
    return gh.dataMatching(from, to, function(from, to) {
      return gh.line(from, to);
    });
  };
  gh.makePolyline = function(points) {
    return gh.dataMatching({
      LIST: points
    }, function(points) {
      return gh.polyline(points);
    });
  };
  gh.makeSpline = function(points) {
    return gh.dataMatching({
      LIST: points
    }, function(points) {
      return gh.spline(points);
    });
  };
  gh.splitPolylineSegments = function(polyline) {
    return gh.dataMatching(polyline, function(polyline) {
      var i, segments;

      segments = (function() {
        var _i, _ref7, _results;

        _results = [];
        for (i = _i = 0, _ref7 = polyline.points.length - 1; 0 <= _ref7 ? _i < _ref7 : _i > _ref7; i = 0 <= _ref7 ? ++_i : --_i) {
          _results.push(gh.line(polyline.points[i], polyline.points[i + 1]));
        }
        return _results;
      })();
      return segments;
    });
  };
  gh.series = function(start, end) {
    var _i, _results;

    return (function() {
      _results = [];
      for (var _i = start; start <= end ? _i <= end : _i >= end; start <= end ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
  };
  gh.bakePoints = function() {
    var lineBuilder, point, pointListSet, s, _i, _len;

    pointListSet = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    lineBuilder = new LineBuilder();
    s = 0.1;
    for (_i = 0, _len = pointListSet.length; _i < _len; _i++) {
      point = pointListSet[_i];
      gh.dataMatching(point, function(point) {
        lineBuilder.addLine(point.dup().add(new Vec3(-s, 0, 0)), point.dup().add(new Vec3(s, 0, 0)));
        lineBuilder.addLine(point.dup().add(new Vec3(0, -s, 0)), point.dup().add(new Vec3(0, s, 0)));
        return lineBuilder.addLine(point.dup().add(new Vec3(0, 0, -s)), point.dup().add(new Vec3(0, 0, s)));
      });
    }
    return lineBuilder;
  };
  gh.bakeLines = function() {
    var line, lineBuilder, lineListSet, _i, _len;

    lineListSet = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    lineBuilder = new LineBuilder();
    for (_i = 0, _len = lineListSet.length; _i < _len; _i++) {
      line = lineListSet[_i];
      gh.dataMatching(line, function(line) {
        return lineBuilder.addLine(line.from, line.to);
      });
    }
    return lineBuilder;
  };
  gh.getBranch = function(tree, path) {
    var key, keys;

    keys = path.map(function(p) {
      return p;
    });
    keys.shift();
    while (keys.length > 0) {
      key = keys.shift();
      tree = tree[key];
    }
    return tree;
  };
  gh.dataMatching = function() {
    var currentInputs, f, i, inputInfos, inputTrees, inputTypes, inputValues, inputs, maxLength, pathResults, paths, result, _i;

    inputInfos = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), f = arguments[_i++];
    inputs = inputInfos.map(function(input) {
      if (input.LIST) {
        return input.LIST;
      } else {
        return input;
      }
    });
    inputTypes = inputInfos.map(function(input) {
      if (input.LIST) {
        return 'LIST';
      } else {
        return 'VALUE';
      }
    });
    inputTrees = inputs.filter(function(input) {
      return gh.isTree(input);
    });
    if (inputTrees.length === 0) {
      currentInputs = inputs;
      maxLength = gh.maxLen(currentInputs, inputTypes);
      result = (function() {
        var _j, _results;

        _results = [];
        for (i = _j = 0; 0 <= maxLength ? _j < maxLength : _j > maxLength; i = 0 <= maxLength ? ++_j : --_j) {
          inputValues = currentInputs.map(function(input, inputIndex) {
            if (gh.isList(input)) {
              return input[i % input.length];
            } else {
              return input;
            }
          });
          _results.push(f.apply(null, inputValues));
        }
        return _results;
      })();
      return result;
    } else if (inputTrees.length === 1) {
      paths = gh.listPaths(inputTrees[0]);
      pathResults = paths.map(function(path) {
        currentInputs = inputs.map(function(input) {
          if (gh.isTree(input)) {
            return gh.getBranch(input, path);
          } else if (gh.isList(input)) {
            return input;
          } else {
            return input;
          }
        });
        maxLength = gh.maxLen(currentInputs, inputTypes);
        result = (function() {
          var _j, _results;

          _results = [];
          for (i = _j = 0; 0 <= maxLength ? _j < maxLength : _j > maxLength; i = 0 <= maxLength ? ++_j : --_j) {
            inputValues = currentInputs.map(function(input, inputIndex) {
              if (gh.isList(input)) {
                if (inputTypes[inputIndex] === 'LIST') {
                  return input;
                } else {
                  return input[i % input.length];
                }
              } else {
                return input;
              }
            });
            _results.push(f.apply(null, inputValues));
          }
          return _results;
        })();
        return result;
      });
      return pathResults;
    } else {
      return 'throw unupported data to match';
    }
  };
  gh.random = function(n, domain, seed) {
    var i, _i, _results;

    if (n == null) {
      n = 1;
    }
    if (domain == null) {
      domain = gh.interval(0, 1);
    }
    _results = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      _results.push(domain.min + domain.range * random());
    }
    return _results;
  };
  gh.randomPoint = function(n, domain, seed, normalize) {
    var x, y, z;

    if (n == null) {
      n = 1;
    }
    if (domain == null) {
      domain = gh.interval(-1, 1);
    }
    if (normalize == null) {
      normalize = true;
    }
    x = gh.random(n, domain, seed);
    y = gh.random(n, domain, seed);
    z = gh.random(n, domain, seed);
    return gh.makePoint(x, y, z);
  };
  gh.makePoint = function(x, y, z) {
    return gh.dataMatching(x, y, z, function(x, y, z) {
      return new Vec3(x, y, z);
    });
  };
  gh.normalize = function(point) {
    return gh.dataMatching(point, function(point) {
      return point.dup().normalize();
    });
  };
  gh.move = function(point, offset) {
    if (offset == null) {
      offset = gh.point(0, 0, 0);
    }
    return gh.dataMatching(point, offset, function(point, offset) {
      return point.dup().add(offset);
    });
  };
  gh.add = gh.move;
  gh.divide = function(curve, n) {
    n = n + 1;
    return gh.dataMatching(curve, n, function(curve, n) {
      var i, numSegments, points, _i;

      numSegments = curve.closed ? n : max(1, n - 1);
      points = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        points.push(curve.pointAt(i / numSegments));
      }
      return points;
    });
  };
  gh.divideToTangents = function(curve, n) {
    n = n + 1;
    return gh.dataMatching(curve, n, function(curve, n) {
      var i, np, numSegments, p, points, _i;

      numSegments = curve.closed ? n : max(1, n - 1);
      points = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        p = curve.pointAt(i / numSegments);
        if (i / numSegments > 0.99999) {
          np = curve.pointAt(i / numSegments - 0.5 / numSegments);
          points.push(p.sub(np).normalize());
        } else {
          np = curve.pointAt(i / numSegments + 0.5 / numSegments);
          points.push(np.sub(p).normalize());
        }
      }
      return points;
    });
  };
  gh.flatten = function(tree) {
    var branch, path, result, _i, _len, _ref7;

    result = [];
    _ref7 = gh.listPaths(tree);
    for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
      path = _ref7[_i];
      branch = gh.getBranch(tree, path);
      result = result.concat(branch);
    }
    return result;
  };
  gh.replace = function(tree, value) {
    return gh.dataMatching(tree, value, function(tree, value) {
      return value;
    });
  };
  gh.rotate = function(point, axis, angle) {
    return gh.dataMatching(point, axis, angle, function(point, axis, angle) {
      var line, p, pointCopy, _i, _len, _ref7;

      if (point.points) {
        pointCopy = point.clone();
        _ref7 = pointCopy.points;
        for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
          p = _ref7[_i];
          p.transformQuat(Quat.create().setAxisAngle(axis, angle));
        }
        return pointCopy;
      } else if (point.from && point.to) {
        line = point;
        return gh.line(line.from.dup().transformQuat(Quat.create().setAxisAngle(axis, angle)), line.to.dup().transformQuat(Quat.create().setAxisAngle(axis, angle)));
      } else {
        return point.dup().transformQuat(Quat.create().setAxisAngle(axis, angle));
      }
    });
  };
  gh.mul = function(a, b) {
    return gh.dataMatching(a, b, function(a, b) {
      return a * b;
    });
  };
  return Window.create({
    settings: {
      fullscreen: Platform.isBrowser,
      width: 1280 * 2,
      height: 720 * 2
    },
    init: function() {
      var geom, geomFlat,
        _this = this;

      this.material = new SolidColor({
        color: Color.Red,
        pointSize: 20
      });
      this.gui = new GUI(this, 0, 0, Platform.isEjecta ? 2 : 1);
      settings().init(this.gui);
      this.gui.enabled = true;
      this.camera = new PerspectiveCamera(60, this.width / this.height, 3, 15);
      this.arcball = new Arcball(this, this.camera, 10);
      this.intances = [];
      geom = hem().fromGeometry(new Cube(2, 0.25, 1));
      geom.splitFaceAtPoint(geom.faces[0], geom.faces[0].getCenter());
      geom.vertices[geom.vertices.length - 1].selected = true;
      geom.pull(2);
      geom.subdivide().subdivide();
      geomFlat = geom.toFlatGeometry();
      geomFlat.computeEdges();
      this.mesh = new Mesh(geomFlat, new SolidColor({
        color: Color.Red
      }), {
        useEdges: true
      });
      this.meshFill = new Mesh(geomFlat, new SolidColor({
        color: Color.Black
      }));
      this.showDepthMaterial = new PackDepth({
        near: this.camera.getNear(),
        far: this.camera.getFar()
      });
      this.diffuseMaterial = new Diffuse({
        wrap: 1
      });
      this.meshFill.setMaterial(this.diffuseMaterial);
      return this.on('keyDown', function(e) {
        if (e.str === 'S') {
          _this.needsSave = true;
        }
        if (e.str === 'g') {
          return _this.gui.enabled = !_this.gui.enabled;
        }
      });
    },
    draw: function() {
      var angles, base, brancCurve, branchDivisions, branchHeight, branchRadius, branchSpline, branches, d, indices, instanceColors, instancePositions, instanceScaleX, instanceScaleY, instanceScaleZ, instanceScales, instanceTangents, instanceTangents2, lines, numBranches, p1, p2, p3, p4, petalPath, petalPoints, points, root, scale, t4, ti4, top, trunk, trunkHeight, trunkPoints;

      MathUtils.seed(0);
      this.gl.clearColor(0, 0, 0, 1);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.lineWidth(5);
      if (this.animate) {
        this.shift = Time.frameNumber % 50;
        this.gui.items[0].dirty = true;
      }
      trunkHeight = settings().getFloat('trunkHeight', 3, 1, 5);
      root = gh.makePoint(0, -trunkHeight / 2, 0);
      top = gh.move(root, gh.yvec(trunkHeight));
      branchDivisions = settings().getInt('branchDivisions', 5, 1, 10);
      numBranches = settings().getInt('numBranches', 8, 3, 20);
      branchRadius = settings().getFloat('branchesRadius', 2, 1, 5);
      branchHeight = settings().getFloat('branchHeight', 0.8, 0, 5);
      brancCurve = settings().getFloat('brancCurve', 0.25, 0.0, 0.5);
      p1 = gh.move(d = gh.divide(gh.circle(new Vec3(0, 0, 0), settings().getFloat('branchesRadius', 2, 1, 5)), numBranches), gh.yvec(settings().getFloat('branchHeight', 2.5, 0, 5)));
      lines = gh.makeLine(top, p1);
      angles = gh.mul(360 / numBranches, gh.series(0, numBranches));
      points = [[gh.point(0, 0, 0), gh.point(branchRadius * (1 - brancCurve), branchHeight * (0.5 - brancCurve), 0), gh.point(branchRadius * 1, branchHeight * 1, 0)]];
      petalPath = gh.makePolyline(gh.divide(gh.makeSpline(points), 10));
      petalPath = gh.rotate(petalPath, gh.vector(0, 1, 0), angles);
      petalPoints = gh.divide(petalPath, branchDivisions);
      petalPath = gh.splitPolylineSegments(gh.makePolyline(petalPoints));
      p2 = gh.divide(lines, branchDivisions);
      p3 = gh.offsetRandom(p2, settings().getFloat('curl', 0, 0, 0.4));
      branchSpline = gh.makeSpline(p3);
      branchSpline = gh.makeSpline(petalPoints);
      p4 = gh.divide(branchSpline, branchDivisions);
      t4 = gh.divideToTangents(branchSpline, branchDivisions);
      indices = gh.series(1, branchDivisions + 1);
      ti4 = gh.replace(t4, indices);
      branches = gh.splitPolylineSegments(gh.makePolyline(p4));
      lines = branches;
      trunkPoints = gh.offsetRandom(gh.divide(gh.makeLine(root, top), branchDivisions), settings().getFloat('curl', 0, 0, 0.2) / 2);
      trunk = gh.splitPolylineSegments(gh.makePolyline(gh.divide(gh.makeSpline(trunkPoints), 30)));
      instanceScaleX = settings().getFloat('instanceScaleX', 0.2, 0.01, 1);
      instanceScaleY = settings().getFloat('instanceScaleY', 0.2, 0.01, 1);
      instanceScaleZ = settings().getFloat('instanceScaleZ', 0.4, 0.01, 1);
      instancePositions = gh.flatten(p4);
      instanceTangents = gh.flatten(t4);
      instanceTangents2 = gh.flatten(gh.normalize(gh.add(t4, gh.point(0, settings().getFloat('petal', 0.8, 0, 2)))));
      instanceScales = gh.flatten(ti4);
      seed(0);
      instanceColors = instanceScales.map(function(s) {
        var c, k;

        k = 1.0 - s / (branchDivisions + 1);
        k *= settings().getFloat('colorScale', 1);
        k = (k + settings().getFloat('colorShift', 0)) % 1;
        c = new Color();
        c.setHSV(k, 0.8, 0.8);
        c.a = 1;
        return c;
      });
      scale = new Vec3(instanceScaleX, instanceScaleY, instanceScaleZ);
      this.instances = instancePositions.map(function(pos, i) {
        return {
          position: pos,
          scale: scale.dup().scale(instanceScales[i]),
          rotation: Quat.fromDirection(instanceTangents[i % instanceTangents.length]).dup()
        };
      });
      this.instancesC = instancePositions.map(function(pos, i) {
        return {
          position: pos,
          scale: scale.dup().scale(instanceScales[i]),
          rotation: Quat.fromDirection(instanceTangents[i % instanceTangents.length]).dup(),
          uniforms: {
            diffuseColor: instanceColors[i],
            color: instanceColors[i]
          }
        };
      });
      this.instances2 = instancePositions.map(function(pos, i) {
        return {
          position: pos,
          scale: scale.dup().scale(instanceScales[i]).scale(0.6),
          rotation: Quat.fromDirection(instanceTangents2[i % instanceTangents.length]).dup()
        };
      });
      this.instances2C = instancePositions.map(function(pos, i) {
        return {
          position: pos,
          scale: scale.dup().scale(instanceScales[i]).scale(0.6),
          rotation: Quat.fromDirection(instanceTangents2[i % instanceTangents.length]).dup(),
          uniforms: {
            diffuseColor: instanceColors[i],
            color: instanceColors[i]
          }
        };
      });
      this.pointsGeometry = gh.bakePoints(petalPoints);
      this.linesGeometry = gh.bakeLines(petalPath, trunk);
      if (this.points) {
        this.points.geometry = this.pointsGeometry;
        this.lines.geometry = this.linesGeometry;
      } else {
        this.points = new Mesh(this.pointsGeometry, this.material, {
          primitiveType: this.gl.LINES
        });
        this.lines = new Mesh(this.linesGeometry, this.material, {
          primitiveType: this.gl.LINES
        });
      }
      base = fx().render({
        drawFunc: this.drawStage.bind(this),
        depth: true
      });
      base.blit();
      if (this.gui.enabled) {
        this.gui.draw();
      }
      if (this.needsSave) {
        return this.save();
      }
    },
    drawStage: function() {
      return this.drawStageLine(2);
    },
    drawDepth: function() {
      this.meshFill.setMaterial(this.showDepthMaterial);
      this.drawStageLine(2);
      return this.meshFill.setMaterial(this.diffuseMaterial);
    },
    drawStageLines: function() {
      return this.drawStageLine(20);
    },
    drawStageLine: function(lineWidth) {
      this.gl.lineWidth(2);
      if (this.points && settings().getBool('showPoints', true)) {
        this.points.draw(this.camera);
      }
      this.gl.lineWidth(1);
      if (this.lines) {
        this.lines.draw(this.camera);
      }
      this.gl.lineWidth(lineWidth);
      if (settings().getBool('showInstances', true)) {
        this.meshFill.drawInstances(this.camera, this.instances);
      }
      if (settings().getBool('showPetals', true)) {
        return this.meshFill.drawInstances(this.camera, this.instances2);
      }
    },
    save: function() {
      var baked, bakedGeom, bakedGeom2;

      this.needsSave = false;
      bakedGeom = this.bakeInstances(this.mesh.geometry, this.instances);
      bakedGeom2 = this.bakeInstances(this.mesh.geometry, this.instances2);
      baked = Geometry.merge(bakedGeom, bakedGeom2);
      return ObjWriter.save(baked, 'Flower_' + Date.now() + '.obj');
    },
    bakeInstances: function(baseGeom, instances) {
      var copy, empty, geom, instance, v, _i, _j, _len, _len1, _ref7;

      empty = new Geometry({
        vertices: [],
        faces: [],
        normals: []
      });
      geom = empty;
      for (_i = 0, _len = instances.length; _i < _len; _i++) {
        instance = instances[_i];
        copy = Geometry.merge(empty, baseGeom);
        _ref7 = copy.vertices;
        for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
          v = _ref7[_j];
          v.x *= instance.scale.x;
          v.y *= instance.scale.y;
          v.z *= instance.scale.z;
        }
        copy.rotate(instance.rotation);
        copy.translate(instance.position);
        geom = Geometry.merge(geom, copy);
      }
      return geom;
    }
  });
});

/*
//@ sourceMappingURL=Hopper.map
*/
