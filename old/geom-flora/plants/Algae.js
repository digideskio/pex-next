// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Algae, Arcball, CameraOrbiterTouch, Color, Config, Context, Cube, Cylinder, Diffuse, Dodecahedron, Edge, Gene, Geometry, HexSphere, Icosahedron, Instance, LineBuilder, Mat4, MathUtils, Mesh, Octahedron, PI, PerspectiveCamera, Platform, Quat, RenderTarget, Scene, ScreenImage, ShowDepth, ShowNormals, SolidColor, Sphere, Spline3D, Texture2D, Time, Vec3, Viewport, Window, abs, cos, exp, floor, fx, hem, lerp, log, map, max, min, pex, random, randomFloat, randomVec3, seed, sin, sqrt, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage, Context = _ref3.Context;
  _ref4 = pex.geom, hem = _ref4.hem, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, Edge = _ref4.Edge, Mat4 = _ref4.Mat4, Spline3D = _ref4.Spline3D, Quat = _ref4.Quat;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere, Dodecahedron = _ref5.Dodecahedron, Icosahedron = _ref5.Icosahedron, LineBuilder = _ref5.LineBuilder, HexSphere = _ref5.HexSphere;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils;
  map = MathUtils.map, seed = MathUtils.seed, randomVec3 = MathUtils.randomVec3, randomFloat = MathUtils.randomFloat;
  cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, floor = Math.floor, min = Math.min, max = Math.max, exp = Math.exp, log = Math.log;
  Cylinder = require('geom/gen/Cylinder');
  Config = require('flora/game/Config');
  CameraOrbiterTouch = require('utils/CameraOrbiterTouch');
  Gene = require('flora/plants/Gene');
  Instance = require('flora/plants/Instance');
  fx = require('pex/fx');
  lerp = function(va, vb, t) {
    return Vec3.create(va.x + (vb.x - va.x) * t, va.y + (vb.y - va.y) * t, va.z + (vb.z - va.z) * t);
  };
  return Algae = (function() {
    function Algae(app) {
      var _i, _j, _ref7, _ref8, _results, _results1;

      this.app = app;
      this.type = 'algae';
      this.gl = Context.currentContext.gl;
      this.camera = new PerspectiveCamera(60, this.app.width / this.app.height);
      if (this.app.on) {
        this.cameraController = new CameraOrbiterTouch(this.app, this.camera, 2.5, 45);
      }
      this.splittingTime = 0;
      this.genes = {
        wallThickness: new Gene('wallThickness', 6, 3, 10, {
          type: 'int'
        }),
        modularity: new Gene('modularity', 1, 1, 6, {
          type: 'int'
        }),
        hair: new Gene('hair', 0.6, 0.6, 1.5),
        shape: new Gene('shape', 0, -0.6, 0.6),
        splitting: new Gene('splitting', 0, 100, 20),
        organization: new Gene('organization', 0, 0, 1),
        glow: new Gene('glow', 0.3, 0.3, 1),
        radius: new Gene('radius', 0.4, 0.1, 0.9)
      };
      this.material = new SolidColor({
        color: Config.colors.blue
      });
      this.material = new SolidColor({
        color: Config.colors.blue
      });
      this.materialFill = new SolidColor({
        color: Color.Black
      });
      this.darkGoldMaterial = new SolidColor({
        color: Config.secondaryColors.blue
      });
      this.rebuildGeom();
      this.cellInstances = (function() {
        _results = [];
        for (var _i = 0, _ref7 = this.genes.modularity.max; 0 <= _ref7 ? _i < _ref7 : _i > _ref7; 0 <= _ref7 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function() {
        return new Instance();
      });
      this.cloneInstances = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15].map(function() {
        return new Instance();
      });
      this.babyInstances = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15].map(function() {
        return new Instance();
      });
      this.mesh = new Mesh(this.cookieGeom, this.material, {
        useEdges: true
      });
      this.meshFill = new Mesh(this.cookieGeom, this.materialFill);
      this.mesh.rotation = Quat.create().setAxisAngle(new Vec3(1, 0, 0), 90);
      this.mesh.scale.set(2, 2, 2);
      this.meshFill.rotation = Quat.create().setAxisAngle(new Vec3(1, 0, 0), 90);
      this.meshFill.scale.set(2, 2, 2);
      this.genes.wallThickness.prevValue = this.genes.wallThickness.intValue;
      this.genes.shape.prevValue = this.genes.shape.intValue;
      this.hairGeom = new Cube(1 / 50, 1 / 50, 0.5);
      this.hairGeom.translate(new Vec3(0, 0, 0.5));
      this.hairMesh = new Mesh(this.hairGeom, this.material);
      this.hairInstances = (function() {
        _results1 = [];
        for (var _j = 0, _ref8 = this.genes.modularity.max * 8; 0 <= _ref8 ? _j < _ref8 : _j > _ref8; 0 <= _ref8 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).map(function() {
        return new Instance();
      });
      this.globeGeom = new HexSphere(6);
      this.globeGeom = hem().fromGeometry(this.globeGeom).triangulate().toFlatGeometry();
      this.globeGeom.computeEdges();
      this.globe = new Mesh(this.globeGeom, this.darkGoldMaterial, {
        useEdges: true
      });
    }

    Algae.prototype.rebuildGeom = function(geom) {
      var UP, face, i, numSides, numSubdivisions, r, wallThickness, _i, _j, _len, _ref7,
        _this = this;

      r = this.genes.radius.value;
      UP = new Vec3(0, 1, 0);
      wallThickness = this.genes.wallThickness.intValue;
      numSides = 3;
      numSubdivisions = 0;
      if (wallThickness >= 3) {
        numSides = 3;
        numSubdivisions = 1;
      }
      if (wallThickness >= 4) {
        numSides = 4;
        numSubdivisions = 1;
      }
      if (wallThickness >= 5) {
        numSides = 4;
        numSubdivisions = 2;
      }
      if (wallThickness >= 6) {
        numSides = 5;
        numSubdivisions = 2;
      }
      if (wallThickness >= 7) {
        numSides = 6;
        numSubdivisions = 2;
      }
      if (wallThickness >= 8) {
        numSides = 7;
        numSubdivisions = 2;
      }
      if (wallThickness >= 9) {
        numSides = 7;
        numSubdivisions = 3;
      }
      if (wallThickness >= 10) {
        numSides = 8;
        numSubdivisions = 3;
      }
      this.cookieGeom = new Cylinder(r, r, numSides, 1);
      this.facesToExtrude = [];
      this.cookieHem = hem().fromGeometry(this.cookieGeom);
      this.cookieHem.faces.forEach(function(face) {
        if (face.getNormal().dot(UP) === 0) {
          return _this.facesToExtrude.push(face);
        }
      });
      this.cookieHem.vertices.forEach(function(v) {
        var len;

        len = sqrt(v.position.x * v.position.x + v.position.z * v.position.z);
        if (len > 0) {
          v.position.x = v.position.x / len * r;
          return v.position.z = v.position.z / len * r;
        }
      });
      _ref7 = this.facesToExtrude;
      for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
        face = _ref7[_i];
        face.selected = true;
        this.cookieHem.extrude(r * (0.5 + random() * this.genes.shape.value));
        face.selected = false;
      }
      if (numSubdivisions) {
        for (i = _j = 0; 0 <= numSubdivisions ? _j < numSubdivisions : _j > numSubdivisions; i = 0 <= numSubdivisions ? ++_j : --_j) {
          this.cookieHem.subdivide(true);
        }
      }
      return this.cookieGeom = this.cookieHem.toFlatGeometry(geom);
    };

    Algae.prototype.animateInstances = function(instances) {
      var instance, instanceIndex, _i, _len, _results;

      _results = [];
      for (instanceIndex = _i = 0, _len = instances.length; _i < _len; instanceIndex = ++_i) {
        instance = instances[instanceIndex];
        _results.push(instance.update());
      }
      return _results;
    };

    Algae.prototype.rebuild = function() {
      var baby, cloneInstance, cloneInstanceIndex, clonningStage, h, hair, hairIndex, instance, instanceIndex, numCells, numSides, numSubdivisions, r, scale, wallThickness, _i, _j, _k, _len, _len1, _ref7, _ref8, _results;

      wallThickness = this.genes.wallThickness.intValue;
      numSides = 3;
      numSubdivisions = 0;
      if (wallThickness >= 3) {
        numSides = 3;
        numSubdivisions = 1;
      }
      if (wallThickness >= 4) {
        numSides = 4;
        numSubdivisions = 1;
      }
      if (wallThickness >= 5) {
        numSides = 4;
        numSubdivisions = 2;
      }
      if (wallThickness >= 6) {
        numSides = 5;
        numSubdivisions = 2;
      }
      if (wallThickness >= 7) {
        numSides = 6;
        numSubdivisions = 2;
      }
      if (wallThickness >= 8) {
        numSides = 7;
        numSubdivisions = 2;
      }
      if (wallThickness >= 9) {
        numSides = 7;
        numSubdivisions = 3;
      }
      if (wallThickness >= 10) {
        numSides = 8;
        numSubdivisions = 3;
      }
      r = this.genes.radius.value;
      numCells = this.genes.modularity.intValue;
      hairIndex = 0;
      _ref7 = this.cellInstances;
      for (instanceIndex = _i = 0, _len = _ref7.length; _i < _len; instanceIndex = ++_i) {
        instance = _ref7[instanceIndex];
        if (instanceIndex < numCells) {
          instance.targetScale.set(1, 1, 1);
          instance.targetPosition.set(0, (instanceIndex - numCells / 2) * r + r / 2, 0);
        } else {
          instance.targetScale.set(0, 0, 0);
        }
        for (h = _j = 0; _j < 8; h = ++_j) {
          hair = this.hairInstances[hairIndex];
          if (!hair) {
            continue;
          }
          hair.targetPosition.copy(instance.targetPosition);
          hair.position.copy(instance.targetPosition);
          if (h < numSides) {
            hair.targetScale.copy(instance.targetScale);
            hair.targetScale.z *= this.genes.hair.value;
          } else {
            hair.targetScale.set(0, 0, 0);
          }
          hair.targetRotation.setAxisAngle(new Vec3(0, 1, 0), (h + 0.5) / numSides * 360);
          hair.rotation.setAxisAngle(new Vec3(0, 1, 0), (h + 0.5) / numSides * 360);
          hairIndex++;
        }
      }
      seed(0);
      _ref8 = this.cloneInstances;
      _results = [];
      for (cloneInstanceIndex = _k = 0, _len1 = _ref8.length; _k < _len1; cloneInstanceIndex = ++_k) {
        cloneInstance = _ref8[cloneInstanceIndex];
        cloneInstance.organizedPosition = new Vec3(cos(map(cloneInstanceIndex, 0, this.cloneInstances.length, 0, PI * 2)), 0, sin(map(cloneInstanceIndex, 0, this.cloneInstances.length, 0, PI * 2)));
        cloneInstance.randomPosition = cloneInstance.organizedPosition.dup().scale(randomFloat(1, 2));
        cloneInstance.randomPosition.y = randomFloat(-1, 1);
        cloneInstance.targetPosition.setVec3(lerp(cloneInstance.randomPosition, cloneInstance.organizedPosition, this.genes.organization.value));
        baby = this.babyInstances[cloneInstanceIndex];
        this.splittingTime += Time.delta;
        if (this.splittingTime > this.genes.splitting.value) {
          this.splittingTime = 0;
        }
        clonningStage = this.splittingTime / (1 + this.genes.splitting.value);
        scale = 0.1 + 0.2 * this.genes.organization.value;
        scale *= 1 - clonningStage;
        cloneInstance.targetScale.set(scale, scale, scale);
        baby.targetScale.set(scale, scale, scale);
        baby.targetPosition.copy(cloneInstance.position);
        cloneInstance.targetPosition.y += scale * clonningStage * 4;
        baby.targetPosition.y -= scale * clonningStage * 8;
        if (this.splittingTime === 0) {
          _results.push(baby.position.copy(baby.targetPosition));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Algae.prototype.update = function() {
      if (this.genes.wallThickness.intValue !== this.genes.wallThickness.prevValue || this.genes.shape.value !== this.genes.shape.prevValue) {
        this.genes.wallThickness.prevValue = this.genes.wallThickness.intValue;
        this.genes.shape.prevValue = this.genes.shape.value;
        this.rebuildGeom(this.cookieGeom);
      }
      if (this.cameraController) {
        this.cameraController.update();
      }
      this.rebuild();
      this.animateInstances(this.cellInstances);
      this.animateInstances(this.hairInstances);
      this.animateInstances(this.cloneInstances);
      return this.animateInstances(this.babyInstances);
    };

    Algae.prototype.drawScene = function() {
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.disable(this.gl.BLEND);
      this.gl.lineWidth(2);
      this.globe.draw(this.camera);
      this.meshFill.drawInstances(this.camera, this.cellInstances);
      this.mesh.drawInstances(this.camera, this.cellInstances);
      this.meshFill.drawInstances(this.camera, this.cloneInstances);
      this.mesh.drawInstances(this.camera, this.cloneInstances);
      this.meshFill.drawInstances(this.camera, this.babyInstances);
      this.mesh.drawInstances(this.camera, this.babyInstances);
      return this.hairMesh.drawInstances(this.camera, this.hairInstances);
    };

    Algae.prototype.drawScene2 = function() {
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.disable(this.gl.BLEND);
      this.gl.lineWidth(10);
      this.meshFill.drawInstances(this.camera, this.cellInstances);
      this.mesh.drawInstances(this.camera, this.cellInstances);
      this.meshFill.drawInstances(this.camera, this.cloneInstances);
      this.mesh.drawInstances(this.camera, this.cloneInstances);
      this.meshFill.drawInstances(this.camera, this.babyInstances);
      this.mesh.drawInstances(this.camera, this.babyInstances);
      return this.hairMesh.drawInstances(this.camera, this.hairInstances);
    };

    Algae.prototype.draw = function(projectionCamera) {
      var blurred, color, glow, glowScale, glowing, small;

      this.update();
      if (projectionCamera) {
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.disable(this.gl.BLEND);
        this.globe.draw(projectionCamera);
        this.gl.lineWidth(2);
        this.meshFill.drawInstances(projectionCamera, this.cellInstances);
        this.mesh.drawInstances(projectionCamera, this.cellInstances);
        this.meshFill.drawInstances(projectionCamera, this.cloneInstances);
        this.mesh.drawInstances(projectionCamera, this.cloneInstances);
        this.meshFill.drawInstances(projectionCamera, this.babyInstances);
        this.mesh.drawInstances(projectionCamera, this.babyInstances);
        return this.hairMesh.drawInstances(projectionCamera, this.hairInstances);
      } else {
        glowScale = map(this.genes.wallThickness.intValue, this.genes.wallThickness.min, this.genes.wallThickness.max, 1, 0.5);
        glowScale *= this.genes.glow.value;
        glowScale *= 0.5 + 0.5 * sin(Time.seconds * 4);
        color = fx().render({
          drawFunc: this.drawScene.bind(this),
          depth: true
        });
        glow = color.render({
          drawFunc: this.drawScene2.bind(this),
          depth: true
        });
        small = glow.downsample4();
        blurred = small.blur7().blur7();
        glowing = color.add(blurred, {
          scale: glowScale
        });
        glowing = glowing.add(blurred, {
          scale: glowScale
        });
        return glowing.blit({
          width: this.app.width,
          height: this.app.height
        });
      }
    };

    return Algae;

  })();
});

/*
//@ sourceMappingURL=Algae.map
*/
