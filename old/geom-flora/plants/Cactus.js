// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Arcball, Cactus, CameraOrbiterTouch, Color, Config, Context, Cube, Cylinder, Diffuse, Face3, FlatToonShading, Gene, Geometry, HEDuplicate, HexSphere, Instance, LineBuilder, Mat4, MathUtils, Mesh, ObjWriter, Octahedron, PI, PerspectiveCamera, Platform, Quat, RenderTarget, Scene, ScreenImage, ShowDepth, ShowNormals, SolidColor, Sphere, Texture2D, Time, Vec3, Viewport, Window, abs, clamp, cos, exp, fem, floor, gh, hem, log, map, max, min, pex, random, randomElement, randomFloat, randomVec3, seed, sin, sqrt, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage, Context = _ref3.Context;
  _ref4 = pex.geom, hem = _ref4.hem, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, hem = _ref4.hem, Quat = _ref4.Quat, Mat4 = _ref4.Mat4, Face3 = _ref4.Face3;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere, LineBuilder = _ref5.LineBuilder, HexSphere = _ref5.HexSphere;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils, ObjWriter = _ref6.ObjWriter;
  map = MathUtils.map, randomVec3 = MathUtils.randomVec3, randomFloat = MathUtils.randomFloat, randomElement = MathUtils.randomElement, seed = MathUtils.seed, clamp = MathUtils.clamp;
  cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, floor = Math.floor, min = Math.min, max = Math.max, exp = Math.exp, log = Math.log;
  fem = require('geom/fem');
  CameraOrbiterTouch = require('utils/CameraOrbiterTouch');
  Cylinder = require('geom/gen/Cylinder');
  HEDuplicate = require('geom/hem/HEDuplicate');
  Config = require('flora/game/Config');
  Gene = require('flora/plants/Gene');
  FlatToonShading = require('materials/FlatToonShading');
  Instance = require('flora/plants/Instance');
  gh = require('geom/gh');
  return Cactus = (function() {
    function Cactus(app) {
      this.app = app;
      this.type = 'cactus';
      this.gl = Context.currentContext.gl;
      this.camera = new PerspectiveCamera(60, this.app.width / this.app.height);
      if (this.app.on) {
        this.cameraController = new CameraOrbiterTouch(this.app, this.camera, 2.5, 45);
      }
      this.step = 0;
      this.initGeometry();
    }

    Cactus.prototype.initGeometry = function() {
      var UP, _i, _ref7, _results;

      this.genes = {
        ridges: new Gene('ridges', 24, 8, 36, {
          type: 'int'
        }),
        shape: new Gene('shape', 0.99, 0.5, 1.5),
        flower: new Gene('flower', 0.1, 0, 1),
        branches: new Gene('branches', 0, 1, 5),
        spikes: new Gene('spikes', 0.0, 0.4, 1),
        root: new Gene('root', 0.1, 0.4, 1),
        poison: new Gene('poison', 0, 1, 8)
      };
      this.cactusMaterial = new SolidColor({
        color: Config.colors.gold
      });
      this.cactusMaterialFill = new SolidColor({
        color: Color.Black
      });
      this.cactusPoisonMaterial = new SolidColor({
        color: Config.colors.pink
      });
      this.spikeMaterialFill = new SolidColor({
        color: Config.colors.skyblue
      });
      this.spikeMaterialEdge = new SolidColor({
        color: Color.White
      });
      this.cactusGeom = new Cylinder(0.5, 0.1, 18, 1);
      this.cactusMaterial = new ShowNormals();
      this.cactusMaterial = new FlatToonShading({
        colorBands: Texture2D.load('assets/toon/colors2b.png')
      });
      this.cactusEdgesMaterial = new SolidColor({
        color: Config.colors.blue
      });
      this.goldMaterial = new SolidColor({
        color: Config.colors.gold
      });
      this.darkGoldMaterial = new SolidColor({
        color: Config.secondaryColors.skyblue
      });
      UP = new Vec3(0, 1, 0);
      this.numSpikes = 50;
      this.rebuildGeom();
      this.petalMaterialEdge = new SolidColor({
        color: new Color(0.5, 0.5, 0, 1)
      });
      this.petalMaterialFill = new SolidColor({
        color: new Color(1, 1, 1, 1)
      });
      this.cactusInstances = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function() {
        return new Instance();
      });
      this.petalInstances = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function() {
        return new Instance();
      });
      this.rootInstances = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function() {
        return new Instance();
      });
      this.spikeInstances = (function() {
        _results = [];
        for (var _i = 0, _ref7 = 5 * this.numSpikes; 0 <= _ref7 ? _i < _ref7 : _i > _ref7; 0 <= _ref7 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function() {
        return new Instance();
      });
      this.rootInstances = [0, 1, 2, 3, 4].map(function() {
        return new Instance();
      });
      return this.rebuildExtraGeom();
    };

    Cactus.prototype.rebuildGeom = function() {
      var hemGeom, ridgeSize, rot, up,
        _this = this;

      console.log('rebuildGeom');
      this.numSides = floor(this.genes.ridges.intValue / 2) * 2;
      ridgeSize = map(this.genes.ridges.value, this.genes.ridges.min, this.genes.ridges.max, 1.5, 0.75);
      this.cactusGeom = new Cylinder(0.15, 1, this.numSides, 10);
      hemGeom = hem().fromGeometry(this.cactusGeom);
      up = new Vec3(0, 1, 0);
      hemGeom.vertices.forEach(function(v, vi) {
        var len, n, r;

        n = v.getNormal();
        if (vi < hemGeom.vertices.length - 1 - _this.numSides && vi > _this.numSides) {
          len = sqrt(v.position.x * v.position.x + v.position.z * v.position.z);
          r = 0.3 * ridgeSize;
          if (vi % 2 === 0) {
            r = 0.3 / (1 + ridgeSize);
          }
          v.position.x = v.position.x / len * r;
          return v.position.z = v.position.z / len * r;
        }
      });
      hemGeom.subdivide();
      this.hemGeomGeom = hemGeom.toFlatGeometry();
      this.hemGeomGeom.computeEdges();
      this.highlightsGeom = hemGeom.triangulate().toFlatGeometry();
      this.poisonGeom = hemGeom.toFlatGeometry();
      this.hemGeomGeom.translate(new Vec3(0, 0.5, 0));
      rot = new Quat().setAxisAngle(new Vec3(1, 0, 0), 90);
      this.hemGeomGeom.rotate(rot);
      this.highlightsGeom.translate(new Vec3(0, 0.5, 0));
      this.highlightsGeom.rotate(rot);
      this.poisonGeom.translate(new Vec3(0, 0.5, 0));
      this.poisonGeom.scale(1.001);
      this.poisonGeom.rotate(rot);
      this.highlightsGeom.faces = this.highlightsGeom.faces.filter(function(f, fi) {
        return fi % 2 === 0;
      });
      this.poisonGeom.faces = this.poisonGeom.faces.filter(function(f, fi) {
        return fi % 1 === 0;
      });
      if (!this.cactusMesh) {
        this.cactusMesh = new Mesh(this.hemGeomGeom, this.cactusMaterialFill);
        this.cactusWireframe = new Mesh(this.hemGeomGeom, this.cactusEdgesMaterial, {
          useEdges: true
        });
        this.cactusHightlights = new Mesh(this.highlightsGeom, this.cactusMaterial);
        this.cactusPoison = new Mesh(this.poisonGeom, this.cactusPoisonMaterial);
      } else {
        this.cactusMesh.geometry = this.hemGeomGeom;
        this.cactusWireframe.geometry = this.hemGeomGeom;
        this.cactusHightlights.geometry = this.highlightsGeom;
        this.cactusPoison.geometry = this.poisonGeom;
      }
      this.rootGeom = new Cylinder(0.15, 1, 6, 10);
      this.rootGeom.translate(new Vec3(0, 0.5, 0));
      rot = new Quat().setAxisAngle(new Vec3(1, 0, 0), 90);
      this.rootGeom.rotate(rot);
      this.rootGeom.computeEdges();
      this.rootMeshFill = new Mesh(this.rootGeom, new SolidColor({
        color: Color.Black
      }));
      return this.rootMeshEdges = new Mesh(this.rootGeom, new SolidColor({
        color: Color.White
      }), {
        useEdges: true
      });
    };

    Cactus.prototype.rebuildExtraGeom = function() {
      var line, petalGeom, rot, spike, _i, _len, _ref7;

      petalGeom = hem().fromGeometry(new Cube(2, 0.25, 1));
      petalGeom.splitFaceAtPoint(petalGeom.faces[0], petalGeom.faces[0].getCenter());
      petalGeom.vertices[petalGeom.vertices.length - 1].selected = true;
      petalGeom.pull(2);
      petalGeom.subdivide();
      petalGeom = petalGeom.toFlatGeometry();
      petalGeom.computeEdges();
      this.petalMeshEdges = new Mesh(petalGeom, this.petalMaterialEdge, {
        useEdges: true
      });
      this.petalMeshFill = new Mesh(petalGeom, this.petalMaterialFill);
      spike = new Cube();
      spike = hem().fromGeometry(spike);
      spike.faces[4].getAllVertices().forEach(function(v) {
        v.position.x *= 0.0;
        v.position.y = 1.5;
        return v.position.z *= 0.0;
      });
      spike.subdivide();
      spike = spike.toFlatGeometry();
      rot = new Quat().setAxisAngle(new Vec3(1, 0, 0), 90);
      spike.rotate(rot);
      spike.computeEdges();
      this.spikeMesh = new Mesh(spike, this.spikeMaterialFill);
      this.spikeMeshEdge = new Mesh(spike, this.spikeMaterialEdge, {
        useEdges: true
      });
      this.globeGeom = new HexSphere(6);
      this.globeGeom = hem().fromGeometry(this.globeGeom).triangulate().toFlatGeometry();
      this.globeGeom.computeEdges();
      this.globe = new Mesh(this.globeGeom, this.darkGoldMaterial, {
        useEdges: true
      });
      this.globeLinesGeom = new LineBuilder();
      this.circleLines = gh.flatten(gh.splitPolylineSegments(gh.makePolyline(gh.divide(gh.circle(gh.point(0, 0, 0), 1), 8), true)));
      _ref7 = this.circleLines;
      for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
        line = _ref7[_i];
        this.globeLinesGeom.addLine(line.from, line.to);
      }
      return this.globeLinesMesh = new Mesh(this.globeLinesGeom, this.goldMaterial, {
        primitiveType: this.gl.LINES
      });
    };

    Cactus.prototype.animateInstances = function(instances) {
      var instance, instanceIndex, _i, _len, _results;

      _results = [];
      for (instanceIndex = _i = 0, _len = instances.length; _i < _len; instanceIndex = ++_i) {
        instance = instances[instanceIndex];
        _results.push(instance.update());
      }
      return _results;
    };

    Cactus.prototype.rebuild = function() {
      var branchSize, cactus, cactusIndex, dir, dirVec, flowerPower, i, inst, layerScale, numBranches, numPetals, petal, petalDir, petalIndex, petalSize, pos, root, rootIndex, rot, shapeScale, size, spike, spikeIndex, startPositions, targetPositions, vertexIndex, width, yshift, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _ref10, _ref11, _ref12, _ref7, _ref8, _ref9,
        _this = this;

      shapeScale = this.genes.shape.value;
      width = map(shapeScale, 0.5, 1.5, 1, 0.5);
      numBranches = this.genes.branches.intValue;
      flowerPower = this.genes.flower.value;
      yshift = -0.2 - shapeScale / 3;
      this.cactusInstances[0].targetScale.set(width, width, shapeScale);
      this.cactusInstances[0].targetPosition.y = yshift;
      rot = Quat.fromDirection(new Vec3(0, 1, 0)).dup();
      this.cactusInstances[0].targetRotation = rot.dup();
      seed(14);
      for (i = _i = 0; 0 <= numBranches ? _i < numBranches : _i > numBranches; i = 0 <= numBranches ? ++_i : --_i) {
        branchSize = 0.3;
        inst = this.cactusInstances[i + 1];
        inst.targetPosition = randomVec3(width / 4 + (1 - shapeScale) * 0.5);
        inst.targetPosition.y = randomFloat(shapeScale / 4, shapeScale / 2) * shapeScale + yshift;
        inst.targetScale.set(width / 2, width / 2, shapeScale / 2);
        dirVec = inst.targetPosition.dup();
        dirVec.y += 0.5 + max(0, 1 - shapeScale) * 3;
        dirVec.scale(5.5);
        dirVec.y /= 4;
        dir = Quat.fromDirection(dirVec).dup();
        inst.targetRotation = dir;
      }
      for (i = _j = _ref7 = 1 + numBranches, _ref8 = this.cactusInstances.length; _ref7 <= _ref8 ? _j < _ref8 : _j > _ref8; i = _ref7 <= _ref8 ? ++_j : --_j) {
        this.cactusInstances[i].targetScale.set(0, 0, 0);
      }
      seed(0);
      spikeIndex = 0;
      _ref9 = this.cactusInstances;
      for (cactusIndex = _k = 0, _len = _ref9.length; _k < _len; cactusIndex = ++_k) {
        cactus = _ref9[cactusIndex];
        for (i = _l = 0, _ref10 = this.numSpikes; 0 <= _ref10 ? _l < _ref10 : _l > _ref10; i = 0 <= _ref10 ? ++_l : --_l) {
          size = 0.1 * cactus.scale.x * this.genes.spikes.value;
          vertexIndex = (i * 424) % this.cactusHightlights.geometry.vertices.length;
          pos = this.cactusHightlights.geometry.vertices[vertexIndex].dup();
          pos.x *= cactus.scale.x;
          pos.y *= cactus.scale.y;
          pos.z *= cactus.scale.z;
          pos.transformQuat(cactus.rotation);
          pos.add(cactus.position);
          dir = pos.dup();
          spike = this.spikeInstances[spikeIndex++];
          if (!spike) {
            continue;
          }
          spike.targetScale.set(size, size, size);
          spike.targetPosition.setVec3(pos);
          spike.position.setVec3(pos);
          spike.targetRotation.copy(Quat.fromDirection(dir));
        }
      }
      numPetals = this.petalInstances.length;
      startPositions = gh.flatten(gh.divide(gh.circle(gh.point(0, shapeScale + yshift, 0), 0.1 * flowerPower), numPetals));
      targetPositions = gh.flatten(gh.divide(gh.circle(gh.point(0, shapeScale + yshift + 0.4 + 0.2, 0), 3 * flowerPower), numPetals));
      dir = new Vec3();
      _ref11 = this.petalInstances;
      for (petalIndex = _m = 0, _len1 = _ref11.length; _m < _len1; petalIndex = ++_m) {
        petal = _ref11[petalIndex];
        layerScale = 0.1 * flowerPower;
        petalSize = 1.5;
        dir.asSub(targetPositions[petalIndex], startPositions[petalIndex]);
        dir.y += (petalIndex % 2) * 0.5;
        if (petalIndex % 2 === 0) {
          dir.scale(0.5);
        }
        petalDir = Quat.fromDirection(dir);
        this.petalInstances[petalIndex].targetPosition.setVec3(startPositions[petalIndex]);
        this.petalInstances[petalIndex].targetScale.set(layerScale, layerScale * petalSize, layerScale);
        this.petalInstances[petalIndex].targetRotation.copy(petalDir);
      }
      this.rootTargets = gh.flatten(gh.divide(gh.circle(gh.point(0, -2 - this.genes.root.value, 0), 1 + this.genes.root.value), this.rootInstances.length - 1));
      _ref12 = this.rootInstances;
      for (rootIndex = _n = 0, _len2 = _ref12.length; _n < _len2; rootIndex = ++_n) {
        root = _ref12[rootIndex];
        root.targetScale.set(0.15, 0.15, 0.5 * this.genes.root.value);
        root.targetPosition.set(0, -shapeScale / 2, 0);
        if (rootIndex > 0) {
          root.targetRotation.copy(Quat.fromDirection(this.rootTargets[rootIndex - 1]));
        } else {
          root.targetRotation.copy(Quat.fromDirection(new Vec3(0, -1, 0)));
        }
      }
      this.poisonGeom.faces = this.cactusMesh.geometry.faces.filter(function(f, fi) {
        return (_this.genes.poison.intValue > 0) && (fi % (10 - _this.genes.poison.intValue) === 0);
      });
      if (this.poisonGeom.faces.length === 0) {
        this.poisonGeom.faces.push(new Face3(0, 0, 0));
      }
      return this.poisonGeom.faces.dirty = true;
    };

    Cactus.prototype.update = function() {
      var currNumSides;

      if (Time.frameNumber % 2 === 0) {
        currNumSides = floor(this.genes.ridges.intValue / 2) * 2;
        if (currNumSides !== this.numSides) {
          this.rebuildGeom();
        }
        this.rebuild();
      }
      if (this.cameraController) {
        this.cameraController.update();
      }
      this.animateInstances(this.cactusInstances);
      this.animateInstances(this.petalInstances);
      this.animateInstances(this.rootInstances);
      this.animateInstances(this.spikeInstances);
      return this.animateInstances(this.rootInstances);
    };

    Cactus.prototype.draw = function(projectionCamera) {
      var camera;

      camera = projectionCamera || this.camera;
      this.update();
      this.gl.enable(this.gl.CULL_FACE);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.lineWidth(0.5);
      this.gl.disable(this.gl.BLEND);
      this.cactusMesh.drawInstances(camera, this.cactusInstances);
      this.cactusWireframe.drawInstances(camera, this.cactusInstances);
      this.cactusHightlights.drawInstances(camera, this.cactusInstances);
      this.cactusPoison.drawInstances(camera, this.cactusInstances);
      this.petalMeshFill.drawInstances(camera, this.petalInstances);
      this.petalMeshEdges.drawInstances(camera, this.petalInstances);
      this.spikeMeshEdge.drawInstances(camera, this.spikeInstances);
      this.spikeMesh.drawInstances(camera, this.spikeInstances);
      this.rootMeshFill.drawInstances(camera, this.rootInstances);
      this.rootMeshEdges.drawInstances(camera, this.rootInstances);
      this.gl.lineWidth(2);
      return this.globe.draw(camera);
    };

    return Cactus;

  })();
});

/*
//@ sourceMappingURL=Cactus.map
*/
