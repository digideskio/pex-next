// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Arcball, Color, Cube, Cylinder, Diffuse, Geometry, HEDuplicate, MathUtils, Mesh, ObjWriter, Octahedron, PI, PerspectiveCamera, Platform, Quat, RenderTarget, Scene, ScreenImage, ShowDepth, ShowNormals, SolidColor, Sphere, Texture2D, Time, Vec3, Viewport, Window, abs, atan2, cos, fem, floor, hem, map, pex, quatFromDirection, random, sin, sqrt, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage;
  _ref4 = pex.geom, hem = _ref4.hem, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, hem = _ref4.hem, Quat = _ref4.Quat;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils, ObjWriter = _ref6.ObjWriter;
  cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, atan2 = Math.atan2, floor = Math.floor;
  map = MathUtils.map;
  fem = require('geom/fem');
  Cylinder = require('geom/gen/Cylinder');
  HEDuplicate = require('geom/hem/HEDuplicate');
  quatFromDirection = function(direction) {
    var dfWScale, dir, m, q, right, up;

    dir = MathUtils.getTempVec3('dir');
    dir.copy(direction).normalize();
    up = MathUtils.getTempVec3('up');
    up.set(0, 1, 0);
    right = MathUtils.getTempVec3('right');
    right.asCross(up, dir);
    up.asCross(dir, right);
    right.normalize();
    up.normalize();
    m = MathUtils.getTempMat4('m');
    m.set4x4r(right.x, right.y, right.z, 0, up.x, up.y, up.z, 0, dir.x, dir.y, dir.z, 0, 0, 0, 0, 1);
    q = MathUtils.getTempQuat('q');
    q.w = Math.sqrt(1.0 + m.a11 + m.a22 + m.a33) / 2.0;
    dfWScale = q.w * 4.0;
    q.x = (m.a23 - m.a32) / dfWScale;
    q.y = (m.a31 - m.a13) / dfWScale;
    q.z = (m.a12 - m.a21) / dfWScale;
    return q;
  };
  return Window.create({
    settings: {
      fullscreen: Platform.isBrowser
    },
    init: function() {
      this.step = 0;
      this.initGeometry();
      return this.initCameras();
    },
    initGeometry: function() {
      var bakedGeom, bakedWireGeom, geom, geomFlat, geomWire, numLayers, numSteps, perLayer, right, shiftY, up, _i, _ref7, _results;

      this.cactusMaterial = new ShowNormals();
      geom = hem().fromGeometry(new Cube(0.5, 0.5, 0.1));
      geom.vertices[0].position.scale(0.25);
      geom.vertices[4].sharp = true;
      geom.vertices[2].position.scale(0.25);
      geom.vertices[5].position.scale(0.50);
      geom.subdivide();
      geom.triangulate();
      geomFlat = geom.toFlatGeometry();
      geomWire = geom.toEdgesGeometry(0.001, 0.0001);
      up = new Vec3(0, 1, 0);
      right = new Vec3(0, 0, 1);
      shiftY = -1.5;
      numLayers = 10;
      perLayer = 10;
      numSteps = numLayers * perLayer;
      this.instances = (function() {
        _results = [];
        for (var _i = 0, _ref7 = numSteps - 1; 0 <= _ref7 ? _i <= _ref7 : _i >= _ref7; 0 <= _ref7 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(i) {
        var angle, deg2rad, inLayer, instance, layer, pos, q, r, scale;

        layer = floor(i / perLayer);
        inLayer = i % perLayer;
        angle = inLayer / (perLayer - 1) * 360 - 30;
        deg2rad = PI / 180;
        q = new Quat().setAxisAngle(up, angle);
        shiftY += 0.113;
        r = map(layer, 0, numLayers, 0.25, 0.1);
        scale = map(layer, 0, numLayers, 1, 0.1);
        pos = new Vec3(r * cos(angle * deg2rad), -0.5 + 0.8 * layer / numLayers, r * sin(angle * deg2rad));
        q = quatFromDirection(pos).dup();
        return instance = {
          position: new Vec3(pos.x, shiftY, pos.z),
          scale: new Vec3(scale, scale, scale),
          rotation: q
        };
      });
      bakedGeom = this.bakeInstances(geomFlat, this.instances);
      bakedWireGeom = this.bakeInstances(geomWire, this.instances);
      this.cactusMesh = new Mesh(bakedGeom, this.cactusMaterial);
      return this.cactusWireframe = new Mesh(bakedWireGeom, new SolidColor({
        color: new Color(1, 1, 1, 1)
      }), {
        useEdges: true
      });
    },
    bakeInstances: function(baseGeom, instances) {
      var copy, empty, geom, instance, _i, _len;

      empty = new Geometry({
        vertices: [],
        faces: [],
        normals: []
      });
      geom = empty;
      for (_i = 0, _len = instances.length; _i < _len; _i++) {
        instance = instances[_i];
        copy = Geometry.merge(empty, baseGeom);
        copy.scale(instance.scale.x);
        copy.rotate(instance.rotation);
        copy.translate(instance.position);
        geom = Geometry.merge(geom, copy);
      }
      return geom;
    },
    initCameras: function() {
      this.camera = new PerspectiveCamera(60, this.width / this.height);
      return this.arcball = new Arcball(this, this.camera, 2);
    },
    draw: function() {
      this.gl.enable(this.gl.CULL_FACE);
      this.gl.clearColor(0, 0, 0, 1);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.lineWidth(0.15);
      this.cactusMesh.draw(this.camera);
      return this.cactusWireframe.draw(this.camera);
    }
  });
});

/*
//@ sourceMappingURL=Cactus02.map
*/
