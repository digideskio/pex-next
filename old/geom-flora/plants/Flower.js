// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Arcball, CameraOrbiterTouch, Color, Config, Context, Cube, Cylinder, Diffuse, Dodecahedron, Edge, Flower, Gene, Geometry, HexSphere, Icosahedron, Instance, LineBuilder, Mat4, MathUtils, Mesh, Octahedron, PI, PerspectiveCamera, Platform, Quat, RenderTarget, Scene, ScreenImage, ShowDepth, ShowNormals, SolidColor, Sphere, Spline3D, Texture2D, Time, Timeline, Vec3, Viewport, Window, abs, clamp, cos, exp, floor, gh, hem, log, map, max, min, pex, random, randomFloat, seed, sin, sqrt, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage, Context = _ref3.Context;
  _ref4 = pex.geom, hem = _ref4.hem, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, Edge = _ref4.Edge, Mat4 = _ref4.Mat4, Spline3D = _ref4.Spline3D, Quat = _ref4.Quat;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere, Dodecahedron = _ref5.Dodecahedron, Icosahedron = _ref5.Icosahedron, LineBuilder = _ref5.LineBuilder, HexSphere = _ref5.HexSphere;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils;
  map = MathUtils.map, randomFloat = MathUtils.randomFloat, seed = MathUtils.seed, clamp = MathUtils.clamp;
  cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, floor = Math.floor, min = Math.min, max = Math.max, exp = Math.exp, log = Math.log;
  Cylinder = require('geom/gen/Cylinder');
  Config = require('flora/game/Config');
  Gene = require('flora/plants/Gene');
  Instance = require('flora/plants/Instance');
  Timeline = require('lib/timeline').Timeline;
  CameraOrbiterTouch = require('utils/CameraOrbiterTouch');
  gh = require('geom/gh');
  return Flower = (function() {
    function Flower(app) {
      var UP, coreGeom, leafGeom, line, petalGeom, _i, _j, _k, _l, _len, _ref7, _ref8, _ref9, _results, _results1, _results2;

      this.app = app;
      this.type = 'flower';
      this.gl = Context.currentContext.gl;
      this.camera = new PerspectiveCamera(60, this.app.width / this.app.height);
      if (this.app.on) {
        this.cameraController = new CameraOrbiterTouch(this.app, this.camera, 2.5, 25);
      }
      this.genes = {
        density: new Gene('density', 5, 5, 10),
        layers: new Gene('layers', 2, 1, 4, {
          type: 'int'
        }),
        sepal: new Gene('sepal', 0.2, 0.1, 1),
        size: new Gene('size', 0.75, 0.5, 2),
        stripes: new Gene('stripes', 0.5, 0, 1)
      };
      this.petalMaterial = new SolidColor({
        color: Config.colors.pink.clone()
      });
      this.leafMaterial = new SolidColor({
        color: Config.colors.green
      });
      this.materialFill = new SolidColor({
        color: Color.Black
      });
      this.goldMaterial = new SolidColor({
        color: Config.colors.gold
      });
      this.darkGoldMaterial = new SolidColor({
        color: Config.secondaryColors.pink
      });
      UP = new Vec3(0, 1, 0);
      this.maxNumPetals = this.genes.density.max * this.genes.layers.max;
      this.petalInstances = (function() {
        _results = [];
        for (var _i = 0, _ref7 = this.maxNumPetals; 0 <= _ref7 ? _i < _ref7 : _i > _ref7; 0 <= _ref7 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function() {
        return new Instance();
      });
      this.leafInstances = (function() {
        _results1 = [];
        for (var _j = 0, _ref8 = this.maxNumPetals; 0 <= _ref8 ? _j < _ref8 : _j > _ref8; 0 <= _ref8 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).map(function() {
        return new Instance();
      });
      this.stemInstances = (function() {
        _results2 = [];
        for (_k = 0; _k < 30; _k++){ _results2.push(_k); }
        return _results2;
      }).apply(this).map(function() {
        return new Instance();
      });
      this.coreInstances = [0].map(function() {
        return new Instance();
      });
      petalGeom = hem().fromGeometry(new Cube(2, 0.25, 1));
      petalGeom.splitFaceAtPoint(petalGeom.faces[0], petalGeom.faces[0].getCenter());
      petalGeom.vertices[petalGeom.vertices.length - 1].selected = true;
      petalGeom.pull(2);
      petalGeom.subdivide();
      petalGeom = petalGeom.toFlatGeometry();
      petalGeom.computeEdges();
      this.petalMeshEdges = new Mesh(petalGeom, this.petalMaterial, {
        useEdges: true
      });
      this.petalMeshFill = new Mesh(petalGeom, this.materialFill);
      coreGeom = hem().fromGeometry(new Dodecahedron(0.4)).subdivide().triangulate().toFlatGeometry();
      coreGeom.computeEdges();
      this.coreMeshEdges = new Mesh(coreGeom, this.petalMaterial, {
        useEdges: true
      });
      this.coreMeshFill = new Mesh(coreGeom, this.materialFill);
      this.coreMeshEdges.scale.set(1, 0.2, 1);
      this.coreMeshFill.scale.set(1, 0.2, 1);
      leafGeom = hem().fromGeometry(new Cube(2, 0.25, 1));
      leafGeom.splitFaceAtPoint(leafGeom.faces[0], leafGeom.faces[0].getCenter());
      leafGeom.vertices[leafGeom.vertices.length - 1].selected = true;
      leafGeom.vertices[leafGeom.vertices.length - 1].sharp = true;
      leafGeom.pull(2.3);
      leafGeom.subdivide().subdivide();
      leafGeom = leafGeom.toFlatGeometry();
      leafGeom.computeEdges();
      this.leafMeshEdges = new Mesh(leafGeom, this.leafMaterial, {
        useEdges: true
      });
      this.leafMeshFill = new Mesh(leafGeom, this.materialFill);
      this.stemGeom = new Cube(1, 1, 1);
      this.stemGeom = hem().fromGeometry(this.stemGeom);
      this.stemGeom.faces[0].edgePairLoop(function(edge) {
        return edge.sharp = true;
      });
      this.stemGeom.faces[1].edgePairLoop(function(edge) {
        return edge.sharp = true;
      });
      this.stemGeom = this.stemGeom.subdivide().toFlatGeometry();
      this.stemGeom.translate(new Vec3(0, 0, 0.5));
      this.stemGeom.computeEdges();
      this.stemMeshEdges = new Mesh(this.stemGeom, this.leafMaterial, {
        useEdges: true
      });
      this.stemMeshFill = new Mesh(this.stemGeom, this.materialFill);
      this.globeGeom = new HexSphere(6);
      this.globeGeom = hem().fromGeometry(this.globeGeom).triangulate().toFlatGeometry();
      this.globeGeom.computeEdges();
      this.globe = new Mesh(this.globeGeom, this.darkGoldMaterial, {
        useEdges: true
      });
      this.globeLinesGeom = new LineBuilder();
      this.circleLines = gh.flatten(gh.splitPolylineSegments(gh.makePolyline(gh.divide(gh.circle(gh.point(0, 0, 0), 1), 8), true)));
      _ref9 = this.circleLines;
      for (_l = 0, _len = _ref9.length; _l < _len; _l++) {
        line = _ref9[_l];
        this.globeLinesGeom.addLine(line.from, line.to);
      }
      this.globeLinesMesh = new Mesh(this.globeLinesGeom, this.goldMaterial, {
        primitiveType: this.gl.LINES
      });
    }

    Flower.prototype.animateInstances = function(instances) {
      var instance, instanceIndex, _i, _len, _results;

      _results = [];
      for (instanceIndex = _i = 0, _len = instances.length; _i < _len; instanceIndex = ++_i) {
        instance = instances[instanceIndex];
        _results.push(instance.update());
      }
      return _results;
    };

    Flower.prototype.update = function() {
      if (this.cameraController) {
        this.cameraController.update();
      }
      if (Time.frameNumber % 5 === 0) {
        this.rebuild();
      }
      this.petalMaterial.uniforms.color.b = this.genes.stripes.value;
      this.animateInstances(this.petalInstances);
      this.animateInstances(this.leafInstances);
      this.animateInstances(this.stemInstances);
      return this.animateInstances(this.coreInstances);
    };

    Flower.prototype.rebuild = function() {
      var UP, bendAxis, bendRot, dirRot, direction, i, instancePliability, layerDir, layerI, layerPos, layerRotation, layerScale, leafDir, leafI, leafInstanceIndex, leafPos, numLayers, numLeafLayers, numLeafs, numPetals, petalI, petalInstanceIndex, petalSize, pos, pos1, pos2, rotation, segmentScale, sepalLength, startPositions, stemSegmentIndex, sx, sy, sz, targetPositions, _i, _j, _k, _l, _m, _n, _o, _p, _ref7, _results;

      petalInstanceIndex = 0;
      numLayers = this.genes.layers.value;
      numPetals = this.genes.density.value;
      petalSize = this.genes.size.value;
      sepalLength = this.genes.sepal.value;
      layerRotation = new Quat();
      UP = new Vec3(0, 1, 0);
      layerDir = new Vec3();
      layerPos = new Vec3();
      seed(2);
      this.coreInstances[petalInstanceIndex].targetPosition.set(0, sepalLength / 2, 0);
      this.coreInstances[petalInstanceIndex].targetScale.set(1, 0.5, 1);
      for (layerI = _i = 0; 0 <= numLayers ? _i < numLayers : _i > numLayers; layerI = 0 <= numLayers ? ++_i : --_i) {
        startPositions = gh.flatten(gh.divide(gh.circle(gh.point(0, sepalLength / 2, 0), 0.2), numPetals));
        targetPositions = gh.flatten(gh.divide(gh.circle(gh.point(0, sepalLength / 2 + 0.4 - 0.6 * numLayers / this.genes.layers.max + 0.2 * layerI, 0), 0.6 - 0.1 * layerI), this.genes.density.value));
        layerScale = map(numLayers, this.genes.layers.min, this.genes.layers.max, 0.2, 0.35);
        layerScale *= map(layerI, 0, numLayers, 1, 0.5);
        for (petalI = _j = 0; 0 <= numPetals ? _j < numPetals : _j > numPetals; petalI = 0 <= numPetals ? ++_j : --_j) {
          layerRotation.setAxisAngle(UP, 360 / numPetals / 2 * layerI);
          layerPos.copy(startPositions[petalI]);
          layerDir.copy(targetPositions[petalI]);
          layerDir.y += 0.15 + 0.1 * sin(Time.seconds);
          layerPos.transformQuat(layerRotation);
          layerDir.transformQuat(layerRotation);
          rotation = Quat.fromDirection(layerDir);
          this.petalInstances[petalInstanceIndex].targetPosition.setVec3(layerPos);
          this.petalInstances[petalInstanceIndex].targetScale.set(layerScale, layerScale, layerScale * petalSize);
          this.petalInstances[petalInstanceIndex].targetRotation.copy(rotation);
          petalInstanceIndex++;
        }
      }
      for (i = _k = petalInstanceIndex, _ref7 = this.petalInstances.length; petalInstanceIndex <= _ref7 ? _k < _ref7 : _k > _ref7; i = petalInstanceIndex <= _ref7 ? ++_k : --_k) {
        this.petalInstances[i].targetScale.set(0, 0, 0);
        this.petalInstances[i].targetPosition.set(0, sepalLength / 2, 0);
      }
      numLeafLayers = 3;
      numLeafs = 5;
      leafInstanceIndex = 0;
      for (layerI = _l = 0; 0 <= numLeafLayers ? _l < numLeafLayers : _l > numLeafLayers; layerI = 0 <= numLeafLayers ? ++_l : --_l) {
        startPositions = gh.flatten(gh.divide(gh.circle(gh.point(0, sepalLength / 2 + -0.05 - 0.05 * layerI, 0), 0.2 - 0.06 * layerI), numLeafs * 2));
        targetPositions = gh.flatten(gh.divide(gh.circle(gh.point(0, sepalLength / 2 + 0.3 - 0.1 * numLayers, 0), 0.5), numLeafs * 2));
        for (leafI = _m = 0; 0 <= numLeafs ? _m < numLeafs : _m > numLeafs; leafI = 0 <= numLeafs ? ++_m : --_m) {
          leafPos = startPositions[(leafI * 2 + layerI) % startPositions.length];
          leafDir = targetPositions[(leafI * 2 + layerI) % targetPositions.length].dup().sub(leafPos);
          rotation = Quat.fromDirection(leafDir);
          layerScale = 0.1 * map(numLayers, this.genes.layers.min, this.genes.layers.max, 1, 2);
          this.leafInstances[leafInstanceIndex].targetPosition.setVec3(leafPos);
          this.leafInstances[leafInstanceIndex].targetScale.set(layerScale, layerScale, layerScale);
          this.leafInstances[leafInstanceIndex].targetRotation.copy(rotation);
          leafInstanceIndex++;
        }
      }
      instancePliability = 0.1;
      pos = Vec3.create(0, -0.1 + sepalLength / 2, 0);
      bendAxis = new Vec3(0, 0, 1).transformQuat(Quat.create().setAxisAngle(UP, randomFloat(0, 360)));
      bendRot = Quat.create().setAxisAngle(bendAxis, instancePliability * 10);
      direction = new Vec3(0, -1, 0);
      pos1 = null;
      pos2 = null;
      for (stemSegmentIndex = _n = 0; _n < 10; stemSegmentIndex = ++_n) {
        direction.transformQuat(bendRot);
        dirRot = Quat.fromDirection(direction);
        segmentScale = sepalLength;
        sx = 0.025 * 1;
        sy = 0.025 * 1;
        sz = 0.1 * segmentScale;
        if (stemSegmentIndex === 5) {
          pos1 = pos.dup();
        }
        if (stemSegmentIndex === 7) {
          pos2 = pos.dup();
        }
        this.stemInstances[stemSegmentIndex].targetScale.set(sx, sy, sz);
        this.stemInstances[stemSegmentIndex].targetPosition.setVec3(pos);
        this.stemInstances[stemSegmentIndex].targetRotation.copy(dirRot);
        pos.addScaled(direction, sz);
      }
      direction = new Vec3(1, 1, 0);
      bendAxis = new Vec3(0, 1, 0).transformQuat(Quat.create().setAxisAngle(UP, randomFloat(0, 360)));
      bendRot = Quat.create().setAxisAngle(bendAxis, 10);
      pos = pos1;
      for (stemSegmentIndex = _o = 10; _o < 20; stemSegmentIndex = ++_o) {
        if (!pos1) {
          this.stemInstances[stemSegmentIndex].targetScale.set(0, 0, 0);
          continue;
        }
        direction.transformQuat(bendRot);
        dirRot = Quat.fromDirection(direction);
        segmentScale = this.genes.sepal.value;
        sx = 0.025 * 1;
        sy = 0.025 * 1;
        sz = 0.06 * segmentScale * clamp(map(sepalLength, 0.4, 0.8, 0, 1), 0, 1);
        this.stemInstances[stemSegmentIndex].targetScale.set(sx, sy, sz);
        this.stemInstances[stemSegmentIndex].targetPosition.setVec3(pos);
        this.stemInstances[stemSegmentIndex].targetRotation.copy(dirRot);
        pos.addScaled(direction, sz * 0.8);
      }
      direction = new Vec3(-1, 1, 0);
      pos = pos2;
      _results = [];
      for (stemSegmentIndex = _p = 20; _p < 30; stemSegmentIndex = ++_p) {
        if (!pos2) {
          this.stemInstances[stemSegmentIndex].targetScale.set(0, 0, 0);
          continue;
        }
        direction.transformQuat(bendRot);
        dirRot = Quat.fromDirection(direction);
        segmentScale = this.genes.sepal.value;
        sx = 0.025 * 1;
        sy = 0.025 * 1;
        sz = 0.06 * segmentScale * clamp(map(sepalLength, 0.7, 1, 0, 1), 0, 1);
        this.stemInstances[stemSegmentIndex].targetScale.set(sx, sy, sz);
        this.stemInstances[stemSegmentIndex].targetPosition.setVec3(pos);
        this.stemInstances[stemSegmentIndex].targetRotation.copy(dirRot);
        _results.push(pos.addScaled(direction, sz));
      }
      return _results;
    };

    Flower.prototype.draw = function(projectionCamera) {
      var camera;

      camera = projectionCamera || this.camera;
      this.update();
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.disable(this.gl.BLEND);
      this.gl.lineWidth(2);
      this.petalMeshFill.drawInstances(camera, this.petalInstances);
      this.petalMeshEdges.drawInstances(camera, this.petalInstances);
      this.coreMeshFill.drawInstances(camera, this.coreInstances);
      this.coreMeshEdges.drawInstances(camera, this.coreInstances);
      this.leafMeshFill.drawInstances(camera, this.leafInstances);
      this.leafMeshEdges.drawInstances(camera, this.leafInstances);
      this.stemMeshFill.drawInstances(camera, this.stemInstances);
      this.stemMeshEdges.drawInstances(camera, this.stemInstances);
      return this.globe.draw(camera);
    };

    return Flower;

  })();
});

/*
//@ sourceMappingURL=Flower.map
*/
