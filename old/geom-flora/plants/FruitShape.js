// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Arcball, Color, Cube, Diffuse, Dodecahedron, Edge, GUI, Geometry, Icosahedron, LineBuilder, Mat4, MathUtils, Mesh, Octahedron, PI, PerspectiveCamera, Platform, RenderTarget, Scene, ScreenImage, ShowDepth, ShowNormals, SolidColor, Sphere, Spline3D, Texture2D, Time, Vec3, Viewport, Window, abs, cos, exp, floor, hem, log, map, max, min, pex, random, sin, sqrt, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage;
  _ref4 = pex.geom, hem = _ref4.hem, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, Edge = _ref4.Edge, Mat4 = _ref4.Mat4, Spline3D = _ref4.Spline3D;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere, Dodecahedron = _ref5.Dodecahedron, Icosahedron = _ref5.Icosahedron, LineBuilder = _ref5.LineBuilder;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils;
  map = MathUtils.map;
  cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, floor = Math.floor, min = Math.min, max = Math.max, exp = Math.exp, log = Math.log;
  GUI = pex.gui.GUI;
  return pex.require(['geom/gen/Cylinder', 'lib/PerlinNoise'], function(Cylinder, PerlinNoise) {
    return Window.create({
      settings: {
        fullscreen: Platform.isBrowser
      },
      init: function() {
        this.step = 0;
        this.initUI();
        this.initScene();
        this.initGeometry();
        return this.initCameras();
      },
      initUI: function() {
        var _this = this;

        return this.on('mouseDragged', function(e) {
          return _this.step = 0;
        });
      },
      initScene: function() {
        return this.scene = new Scene();
      },
      initGeometry: function() {
        var cylinderR, evalPos, segment, side, vertexCount, _i, _j, _ref7, _ref8;

        this.cactusMaterial = new ShowNormals();
        cylinderR = 0.05;
        this.cactusGeom = new Cylinder(cylinderR, 1, 24, 16, false);
        this.cactusGeom.computeEdges();
        this.cactusGeom.computeSmoothNormals();
        this.cactusGeom.vertices.forEach(function(v) {
          return v.original = v.dup();
        });
        this.cactusGeom.faces = this.cactusGeom.faces.filter(function(f, fi) {
          return fi % 19 === 0;
        });
        this.cactusWireGeom = new Cylinder(cylinderR, 1, 24, 16, false);
        this.cactusWireGeom.computeEdges();
        this.cactusWireGeom.computeSmoothNormals();
        this.cactusWireGeom.vertices.forEach(function(v) {
          return v.original = v.dup();
        });
        this.cactusWireHighlightsGeom = new Cylinder(cylinderR + 0.01, 1, 24, 16, false);
        this.cactusWireHighlightsGeom.computeEdges();
        this.cactusWireHighlightsGeom.computeSmoothNormals();
        this.cactusWireHighlightsGeom.vertices.forEach(function(v) {
          return v.original = v.dup();
        });
        this.cactusWireHighlightsGeom.edges = this.cactusWireHighlightsGeom.edges.filter(function(e, ei) {
          return ei % 15 === 0;
        });
        evalPos = function(pos, r, theta, phi) {
          pos.x = r * sin(theta) * sin(phi);
          pos.y = r * cos(theta);
          return pos.z = r * sin(theta) * cos(phi);
        };
        this.numSides = 72;
        this.numSegments = 50;
        this.r = 0.25;
        this.cactusWireGeom = new Geometry({
          vertices: true,
          edges: true
        });
        for (side = _i = 0, _ref7 = this.numSides - 1; 0 <= _ref7 ? _i <= _ref7 : _i >= _ref7; side = 0 <= _ref7 ? ++_i : --_i) {
          vertexCount = this.cactusWireGeom.vertices.length;
          for (segment = _j = 0, _ref8 = this.numSegments - 1; 0 <= _ref8 ? _j <= _ref8 : _j >= _ref8; segment = 0 <= _ref8 ? ++_j : --_j) {
            this.cactusWireGeom.vertices.push(new Vec3(this.r * cos(2 * PI * side / this.numSides), map(segment, 0, this.numSegments - 1, -this.r, this.r), this.r * sin(2 * PI * side / this.numSides)));
            if (segment < this.numSegments - 1) {
              this.cactusWireGeom.edges.push(new Edge(vertexCount + segment, vertexCount + segment + 1));
            }
          }
        }
        this.numSides = 32;
        this.numSegments = 20;
        this.cactusWireframe = new Mesh(this.cactusWireGeom, new SolidColor({
          color: new Color(0.2, 0.3, 0.5, 1.0),
          pointSize: 3
        }), {
          useEdges: true
        });
        this.cactusWireframePoints = new Mesh(this.cactusWireGeom, new SolidColor({
          pointSize: 2,
          color: new Color(0.7, 0.7, 0.5, 1.0)
        }), {
          primitiveType: this.gl.POINTS
        });
        this.scene.add(this.cactusWireframe);
        this.appleCurve = 1;
        this.gui = new GUI(this);
        this.gui.addLabel('params');
        this.gui.addParam('appleCurve', this, 'appleCurve', {
          min: 1,
          max: 2
        });
        this.gui.addParam('r', this, 'r', {
          min: 0.1,
          max: 0.5
        });
        this.gui.addParam('numSides', this, 'numSides', {
          min: 3,
          max: 72,
          step: 1
        });
        return this.gui.addParam('numSegments', this, 'numSegments', {
          min: 10,
          max: 50,
          step: 1
        });
      },
      initCameras: function() {
        this.camera = new PerspectiveCamera(60, this.width / this.height);
        return this.arcball = new Arcball(this, this.camera, 1);
      },
      draw: function() {
        var R, a, evalApple, evalAppleRadius, evalPear, evalShape, m, makeSpline, segment, self, side, smin, t, vertexCount, _i, _j, _ref7, _ref8;

        R = 0.052;
        /*
        @cactusGeom.vertices.forEach (v, vi) =>
          r = R
          v.x = v.original.x + r * @cactusGeom.normals[vi].x * sin(v.original.x*20 + v.original.y*20 + Time.seconds)
          v.y = v.original.y + r * @cactusGeom.normals[vi].y * sin(v.original.z*20 + v.original.y*20 + Time.seconds)
          v.z = v.original.z + r * @cactusGeom.normals[vi].z * cos(v.original.z*20 + v.original.z*20 + Time.seconds)
          #r = MathUtils.map(v.original.y, -0.5, 0.5, -0.5, 0.2)
          #v.x += v.original.x + r * @cactusGeom.normals[vi].x
          #v.y += v.original.y + r * @cactusGeom.normals[vi].y
          #v.z += v.original.z + r * @cactusGeom.normals[vi].z
        
        @cactusWireGeom.vertices.forEach (v, vi) =>
          r = R
          #r += MathUtils.map(v.original.y, -0.5, 0.5, 1, 1)
          v.x = v.original.x + r * @cactusWireGeom.normals[vi].x * sin(v.original.x*20 + v.original.y*20 + Time.seconds)
          v.y = v.original.y + r * @cactusWireGeom.normals[vi].y * sin(v.original.z*20 + v.original.y*20 + Time.seconds)
          v.z = v.original.z + r * @cactusWireGeom.normals[vi].z * cos(v.original.z*20 + v.original.z*20 + Time.seconds)
          #r = MathUtils.map(v.original.y, -0.5, 0.5, -0.5, 0.2)
          #v.x += v.original.x + r * @cactusGeom.normals[vi].x
          #v.y += v.original.y + r * @cactusGeom.normals[vi].y
          #v.z += v.original.z + r * @cactusGeom.normals[vi].z
        
        @cactusWireHighlightsGeom.vertices.forEach (v, vi) =>
          r = R
          #r += MathUtils.map(v.original.y, -0.5, 0.5, 1, 1)
          v.x = v.original.x + r * @cactusWireGeom.normals[vi].x * sin(v.original.x*20 + v.original.y*20 + Time.seconds)
          v.y = v.original.y + r * @cactusWireGeom.normals[vi].y * sin(v.original.z*20 + v.original.y*20 + Time.seconds)
          v.z = v.original.z + r * @cactusWireGeom.normals[vi].z * cos(v.original.z*20 + v.original.z*20 + Time.seconds)
        */

        self = this;
        smin = function(a, b, k) {
          var res;

          a = -a;
          b = -b;
          res = exp(-k * a) + exp(-k * b);
          return -log(res) / k;
        };
        evalAppleRadius = function(r, t, c) {
          c = c || 1;
          r = r * (0.5 + 0.5 * (2 - c));
          return r * (c - cos(a));
        };
        evalApple = function(t, a) {
          return [evalAppleRadius(self.r, a, self.appleCurve) * sin(a), evalAppleRadius(self.r, a, self.appleCurve) * cos(a) + self.r / 2];
        };
        makeSpline = function(points) {
          var points3d, spline;

          points3d = points.map(function(p) {
            return new Vec3(p[0], p[1], 0);
          });
          return spline = new Spline3D(points3d);
        };
        if (!this.pearShape) {
          this.pearShape = makeSpline([[0, 0], [0.1, 0.25], [0.25, 0.25], [0.35, 0.5], [0.65, 1], [1, 0]]);
        }
        evalPear = function(t, a) {
          var p;

          p = self.pearShape.getPointAt(t);
          return [self.r * p.y, 2 * self.r * (p.x - 0.5)];
        };
        m = new Mat4();
        for (side = _i = 0, _ref7 = this.numSides - 1; 0 <= _ref7 ? _i <= _ref7 : _i >= _ref7; side = 0 <= _ref7 ? ++_i : --_i) {
          vertexCount = side * this.numSegments;
          m.identity();
          m.rotate(map(side, 0, this.numSides, 0, 2 * PI), 0, 1, 0);
          evalShape = evalApple;
          evalShape = evalPear;
          for (segment = _j = 0, _ref8 = this.numSegments - 1; 0 <= _ref8 ? _j <= _ref8 : _j >= _ref8; segment = 0 <= _ref8 ? ++_j : --_j) {
            t = segment / (this.numSegments - 1);
            a = t * PI;
            if (!this.cactusWireGeom.vertices[vertexCount + segment]) {
              this.cactusWireGeom.vertices[vertexCount + segment] = new Vec3();
            }
            this.cactusWireGeom.vertices[vertexCount + segment].set(evalShape(t, a)[0], evalShape(t, a)[1], 0);
            this.cactusWireGeom.vertices[vertexCount + segment].transformMat4(m);
          }
        }
        this.cactusWireGeom.vertices.length = floor(this.numSides) * floor(this.numSegments);
        this.cactusWireGeom.vertices.dirty = true;
        this.gl.enable(this.gl.CULL_FACE);
        this.gl.clearColor(0, 0, 0, 1);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.lineWidth(1);
        this.cactusWireframe.draw(this.camera);
        this.cactusWireframePoints.draw(this.camera);
        return this.gui.draw();
      }
    });
  });
});

/*
//@ sourceMappingURL=FruitShape.map
*/
