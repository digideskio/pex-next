// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Arcball, Color, Context, Cube, Diffuse, Dodecahedron, Edge, GUI, Geometry, Icosahedron, LineBuilder, Loft, Mat4, MathUtils, Mesh, Octahedron, PI, PerspectiveCamera, Platform, Quat, RenderTarget, Scene, ScreenImage, ShowColors, ShowDepth, ShowNormals, SolidColor, Sphere, Spline1D, Spline3D, Texture2D, Time, Vec3, Viewport, Window, abs, cos, exp, floor, hem, log, map, max, min, mix, pex, random, randomFloat, randomInt, seed, settings, sin, sqrt, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals, ShowColors = _ref2.ShowColors;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage, Context = _ref3.Context;
  _ref4 = pex.geom, hem = _ref4.hem, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, Edge = _ref4.Edge, Mat4 = _ref4.Mat4, Spline3D = _ref4.Spline3D, Quat = _ref4.Quat;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere, Dodecahedron = _ref5.Dodecahedron, Icosahedron = _ref5.Icosahedron, LineBuilder = _ref5.LineBuilder;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils;
  map = MathUtils.map, randomFloat = MathUtils.randomFloat, randomInt = MathUtils.randomInt, seed = MathUtils.seed;
  cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, floor = Math.floor, min = Math.min, max = Math.max, exp = Math.exp, log = Math.log;
  Scene = pex.scene.Scene;
  GUI = pex.gui.GUI;
  Spline1D = require('geom/Spline1D');
  Loft = require('geom/Loft');
  settings = require('utils/Settings');
  mix = function(a, b, t) {
    return a + t * (b - a);
  };
  return Window.create({
    settings: {
      fullscreen: Platform.isBrowser,
      width: 2560,
      height: 1380
    },
    init: function() {
      Time.verbose = true;
      this.gui = new GUI(this);
      settings().init(this.gui);
      this.gl = Context.currentContext.gl;
      this.camera = new PerspectiveCamera(60, this.width / this.height);
      this.arcball = new Arcball(this, this.camera, 7.5);
      return this.material = new ShowNormals();
    },
    makeScene: function() {
      var UP, bending, d, height, i, j, layer, loft, maxBending, mesh, numLayers, numLeafs, numPoints, numSegments, numSteps, p, path, plantPoints, points, r, rotation, ru, rv, thickness, wireframe, x, y, z, _i, _j, _k, _l, _ref7, _ref8, _ref9, _results, _results1, _results2, _results3;

      numSteps = settings().getInt('numSteps', 20, 10, 500);
      numSegments = settings().getInt('numSegments', 8, 4, 32);
      wireframe = settings().getBool('wireframe', true);
      numLeafs = settings().getInt('numLeafs', 3, 1, 30);
      numLayers = settings().getInt('numLayers', 3, 1, 10);
      maxBending = settings().getFloat('maxBending', 0.5, 0, 10);
      height = settings().getFloat('height', 1, 0, 5);
      thickness = settings().getFloat('thickness', 0.5, 0, 3);
      ru = new Spline1D((function() {
        _results = [];
        for (var _i = 0, _ref7 = numSteps - 1; 0 <= _ref7 ? _i <= _ref7 : _i >= _ref7; 0 <= _ref7 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(i) {
        var t;

        t = i / numSteps;
        if (i === 0) {
          return 0;
        } else if (i >= numSteps - 1) {
          return 0;
        } else {
          return 0.05 + t * t * (0.35 + 0.3 * sin(t * PI * 6));
        }
      }));
      rv = new Spline1D((function() {
        _results1 = [];
        for (var _j = 0, _ref8 = numSteps - 1; 0 <= _ref8 ? _j <= _ref8 : _j >= _ref8; 0 <= _ref8 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).map(function(i) {
        if (i === 0) {
          return 0;
        } else if (i >= numSteps - 1) {
          return 0;
        } else {
          return (0.15 + 0.05 * sin(i / numSteps * PI * 6)) / 2;
        }
      }));
      r = new Spline1D((function() {
        _results2 = [];
        for (var _k = 0, _ref9 = numSteps - 1; 0 <= _ref9 ? _k <= _ref9 : _k >= _ref9; 0 <= _ref9 ? _k++ : _k--){ _results2.push(_k); }
        return _results2;
      }).apply(this).map(function(i) {
        var t;

        t = i / numSteps;
        return 0.15 * (1 - t);
      }));
      this.scene = new Scene();
      UP = new Vec3(0, 1, 0);
      seed(0);
      numPoints = 10;
      _results3 = [];
      for (layer = _l = 0; 0 <= numLayers ? _l < numLayers : _l > numLayers; layer = 0 <= numLayers ? ++_l : --_l) {
        _results3.push((function() {
          var _m, _results4;

          _results4 = [];
          for (i = _m = 0; 0 <= numLeafs ? _m < numLeafs : _m > numLeafs; i = 0 <= numLeafs ? ++_m : --_m) {
            bending = 1 / numPoints / 2 * randomFloat(maxBending, 1);
            d = 0;
            rotation = Quat.create().setAxisAngle(UP, 360 * 0.2 * i / numLeafs + 90 * layer / numLayers);
            plantPoints = randomInt(numPoints / 2, numPoints);
            points = (function() {
              var _n, _results5;

              _results5 = [];
              for (j = _n = 0; 0 <= plantPoints ? _n < plantPoints : _n > plantPoints; j = 0 <= plantPoints ? ++_n : --_n) {
                d += bending * j;
                x = d;
                y = height * j * 0.5 - d + layer * 0.6 - height + 0.5;
                z = 0;
                _results5.push(p = new Vec3(x, y, z));
              }
              return _results5;
            })();
            path = new Spline3D(points);
            loft = new Loft(path, {
              numSteps: numSteps,
              numSegments: numSegments,
              caps: false,
              r: r,
              ru2: ru,
              rv2: rv
            });
            loft.rotate(rotation);
            loft = hem().fromGeometry(loft).toFlatGeometry();
            mesh = new Mesh(loft, this.material, {
              useEdges: wireframe
            });
            mesh.position.y = -2;
            mesh.position.x = randomFloat(-1, 1);
            mesh.position.z = randomFloat(-1, 1);
            _results4.push(this.scene.add(mesh));
          }
          return _results4;
        }).call(this));
      }
      return _results3;
    },
    makeDebugScene: function() {
      var all, lineBuilder, loft, makeTorus, mesh, numSteps, p, q, ru, rv, spin, spline, splineIndex, splines, torus, wireframe, _i, _j, _k, _l, _len, _ref7, _ref8, _results, _results1, _results2, _results3;

      makeTorus = function(p, q) {
        return function(t) {
          var a, r, x, y, z;

          a = 2 * PI * t;
          r = cos(q * a) + 2;
          x = r * cos(p * a);
          y = r * sin(p * a);
          z = -sin(q * a);
          return new Vec3(x, y, z);
        };
      };
      p = settings().getInt('p', 3, 1, 5);
      q = settings().getInt('q', 1, -5, 5);
      torus = makeTorus(p, q);
      splines = [];
      all = settings().getBool('all', false);
      if (all) {
        splines.push(new Spline3D([new Vec3(-2, 0, 0), new Vec3(-1, 0, 0), new Vec3(1, 0, 0), new Vec3(2, 0, 0)]));
        splines.push(new Spline3D([new Vec3(0, -2, 0), new Vec3(0, -1, 0), new Vec3(0, 1, 0), new Vec3(0, 2, 0)]));
        splines.push(new Spline3D([new Vec3(0, 0, -2), new Vec3(0, 0, -1), new Vec3(0, 0, 1), new Vec3(0, 0, 2)]));
      }
      splines.push(new Spline3D([new Vec3(-2, 1, 0), new Vec3(-1, 0, 0), new Vec3(1, 1, 2), new Vec3(2, -1, 3)]));
      if (all) {
        splines.push(new Spline3D((function() {
          _results = [];
          for (_i = 0; _i <= 100; _i++){ _results.push(_i); }
          return _results;
        }).apply(this).map(function(i) {
          return torus(i / 100);
        }), true));
        splines.push(new Spline3D([new Vec3(-2, 2, 0), new Vec3(-2, -2, 0), new Vec3(0, 0, 0), new Vec3(2, -2, 0), new Vec3(3, 0, 0), new Vec3(2, 2, 0)], true));
        splines.push(new Spline3D([new Vec3(1, -2, 2), new Vec3(0, -2, -2), new Vec3(0, 2, -2), new Vec3(-1, 2, 2)]));
      }
      this.scene = new Scene();
      numSteps = settings().getInt('numSteps', 100, 10, 500);
      spin = settings().getFloat('spin', -1.82, -10, 10);
      wireframe = settings().getBool('wireframe', true);
      ru = new Spline1((function() {
        _results1 = [];
        for (var _j = 0, _ref7 = numSteps - 1; 0 <= _ref7 ? _j <= _ref7 : _j >= _ref7; 0 <= _ref7 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).map(function(i) {
        if (i === 0) {
          return 0;
        } else if (i >= numSteps - 1) {
          return 0;
        } else {
          return 0.4 + 0.35 * sin(i / numSteps * PI * 4);
        }
      }));
      rv = new Spline1((function() {
        _results2 = [];
        for (var _k = 0, _ref8 = numSteps - 1; 0 <= _ref8 ? _k <= _ref8 : _k >= _ref8; 0 <= _ref8 ? _k++ : _k--){ _results2.push(_k); }
        return _results2;
      }).apply(this).map(function(i) {
        if (i === 0) {
          return 0;
        } else if (i > numSteps - 5) {
          return 0;
        } else {
          return (0.15 + 0.05 * sin(i / numSteps * PI * 6)) / 2;
        }
      }));
      _results3 = [];
      for (splineIndex = _l = 0, _len = splines.length; _l < _len; splineIndex = ++_l) {
        spline = splines[splineIndex];
        lineBuilder = new LineBuilder();
        loft = new Loft(spline, {
          numSteps: numSteps,
          closed: spline.loop,
          spin: spin,
          ru: ru,
          rv: rv
        });
        loft = hem().fromGeometry(loft).toFlatGeometry();
        mesh = new Mesh(loft, new ShowNormals(), {
          useEdges: wireframe
        });
        mesh.position.x = (splineIndex - splines.length / 2 + 0.5) * 5;
        _results3.push(this.scene.add(mesh));
      }
      return _results3;
    },
    draw: function() {
      this.gl.clearColor(0.2, 0.26, 0.3, 1.0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      this.gl.enable(this.gl.DEPTH_TEST);
      if (settings().isDirty() || !this.scene) {
        this.makeScene();
      }
      this.scene.draw(this.camera);
      return this.gui.draw();
    }
  });
});

/*
//@ sourceMappingURL=Loftis.map
*/
