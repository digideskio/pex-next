// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Arcball, Color, Context, Cube, Cylinder, Diffuse, Dodecahedron, Edge, Geometry, Icosahedron, LineBuilder, Mat4, MathUtils, Mesh, ObjWriter, Octahedron, PI, PerspectiveCamera, Platform, Quat, RenderTarget, Scene, ScreenImage, ShowColors, ShowDepth, ShowNormals, SolidColor, Sphere, Spline3D, Texture2D, Time, Vec3, Viewport, Window, abs, cos, exp, floor, hem, log, map, max, min, mix, pex, random, randomFloat, seed, sin, sqrt, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals, ShowColors = _ref2.ShowColors;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage, Context = _ref3.Context;
  _ref4 = pex.geom, hem = _ref4.hem, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, Edge = _ref4.Edge, Mat4 = _ref4.Mat4, Spline3D = _ref4.Spline3D, Quat = _ref4.Quat;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere, Dodecahedron = _ref5.Dodecahedron, Icosahedron = _ref5.Icosahedron, LineBuilder = _ref5.LineBuilder;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils, ObjWriter = _ref6.ObjWriter;
  map = MathUtils.map, randomFloat = MathUtils.randomFloat, seed = MathUtils.seed;
  cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, floor = Math.floor, min = Math.min, max = Math.max, exp = Math.exp, log = Math.log;
  Cylinder = require('geom/gen/Cylinder');
  mix = function(a, b, t) {
    return a + t * (b - a);
  };
  Quat.fromDirection = function(direction, debug) {
    var dfWScale, dir, m, q, q2, right, up;

    q = new Quat();
    dir = MathUtils.getTempVec3('dir');
    dir.copy(direction).normalize();
    up = MathUtils.getTempVec3('up');
    up.set(0, 1, 0);
    right = MathUtils.getTempVec3('right');
    right.asCross(up, dir);
    if (right.length() === 0) {
      up.set(1, 0, 0);
      right.asCross(up, dir);
    }
    up.asCross(dir, right);
    right.normalize();
    up.normalize();
    if (debug) {
      console.log('dir', dir);
    }
    if (debug) {
      console.log('up', up);
    }
    if (debug) {
      console.log('right', right);
    }
    m = MathUtils.getTempMat4('m');
    m.set4x4r(right.x, right.y, right.z, 0, up.x, up.y, up.z, 0, dir.x, dir.y, dir.z, 0, 0, 0, 0, 1);
    q = MathUtils.getTempQuat('q');
    if (1.0 + m.a11 + m.a22 + m.a33 < 0.001) {
      if (debug) {
        console.log('singularity');
      }
      dir = direction.dup();
      dir.z *= -1;
      dir.normalize();
      up.set(0, 1, 0);
      right.asCross(up, dir);
      up.asCross(dir, right);
      right.normalize();
      up.normalize();
      m = MathUtils.getTempMat4('m');
      m.set4x4r(right.x, right.y, right.z, 0, up.x, up.y, up.z, 0, dir.x, dir.y, dir.z, 0, 0, 0, 0, 1);
      q.w = Math.sqrt(1.0 + m.a11 + m.a22 + m.a33) / 2.0;
      dfWScale = q.w * 4.0;
      q.x = (m.a23 - m.a32) / dfWScale;
      q.y = (m.a31 - m.a13) / dfWScale;
      q.z = (m.a12 - m.a21) / dfWScale;
      if (debug) {
        console.log('dir', dir);
      }
      if (debug) {
        console.log('up', up);
      }
      if (debug) {
        console.log('right', right);
      }
      q2 = MathUtils.getTempQuat('q2');
      q2.setAxisAngle(new Vec3(0, 1, 0), 180);
      q2.mul(q);
      return q2;
    }
    q.w = Math.sqrt(1.0 + m.a11 + m.a22 + m.a33) / 2.0;
    dfWScale = q.w * 4.0;
    q.x = (m.a23 - m.a32) / dfWScale;
    q.y = (m.a31 - m.a13) / dfWScale;
    q.z = (m.a12 - m.a21) / dfWScale;
    return q.dup();
  };
  return Window.create({
    settings: {
      fullscreen: Platform.isBrowser,
      width: 2560 / 2,
      height: 1380 / 2
    },
    init: function() {
      var UP, bodyColors, featherColors, i,
        _this = this;

      Time.verbose = true;
      this.on('keyDown', function(e) {
        if (e.str === 'S') {
          _this.needsSave = true;
        }
        if (e.str === 'g') {
          return _this.gui.enabled = !_this.gui.enabled;
        }
      });
      this.gl = Context.currentContext.gl;
      this.camera = new PerspectiveCamera(60, this.width / this.height);
      this.arcball = new Arcball(this, this.camera, 3.5);
      this.material = new ShowColors();
      UP = new Vec3(0, 1, 0);
      this.featherGeom = new Cube(0.15, 0.05, 0.5);
      this.featherGeom = hem().fromGeometry(this.featherGeom).subdivide(true).subdivide(true).toFlatGeometry();
      this.featherGeom.translate(new Vec3(0, 0, 0.25));
      featherColors = this.featherGeom.vertices.map(function(v) {
        var b, g, k, r;

        k = abs(v.z * 5);
        k /= 4;
        r = mix(0.1, 0.6, k);
        g = mix(0.3, 0.8, k);
        b = mix(0.4, 0.2, k);
        return new Color(r, g, b, 1);
      });
      this.featherGeom.addAttrib('colors', 'color', featherColors);
      this.featherMesh = new Mesh(this.featherGeom, this.material);
      this.body = new Cylinder(0.24, 2);
      this.body = hem().fromGeometry(this.body).selectRandomFaces(0.5).extrude(0.1).subdivide(true).subdivide(true).toFlatGeometry();
      bodyColors = this.body.vertices.map(function(v) {
        var b, g, k, r;

        k = abs(v.y / 2);
        k = k + abs(v.z);
        k = 1 - k * 1.5;
        k = 0;
        r = mix(0.1, 1.0, k);
        g = mix(0.3, 0.2, k);
        b = mix(0.4, 0.2, k);
        return new Color(r, g, b, 1);
      });
      this.body.addAttrib('colors', 'color', bodyColors);
      this.body.computeSmoothNormals();
      this.mesh = new Mesh(this.body, this.material);
      this.anchorPoints = this.body.vertices.filter(function(v) {
        return abs(v.dot(UP)) <= 0.90;
      });
      this.anchorPoints.sort(function(a, b) {
        if (a.x > b.x) {
          return 1;
        }
        if (a.y > b.y) {
          return 1;
        }
        if (a.z > b.z) {
          return 1;
        }
        if (a.x === b.x && a.y === b.y && a.z === b.z) {
          return 0;
        }
        return -1;
      });
      console.log('before', this.anchorPoints.length);
      i = 0;
      while (i < this.anchorPoints.length - 1) {
        if (this.anchorPoints[i].distance(this.anchorPoints[i + 1]) < 0.0001) {
          this.anchorPoints.splice(i, 1);
        } else {
          i++;
        }
      }
      console.log('after', this.anchorPoints.length);
      this.anchorPointsGeom = new Geometry({
        vertices: this.anchorPoints,
        faces: null
      });
      return this.anchorPointsMesh = new Mesh(this.anchorPointsGeom, new SolidColor({
        color: Color.Yellow,
        pointSize: 4
      }), {
        primitiveType: this.gl.POINTS
      });
    },
    save: function() {
      var baked, bakedGeom;

      this.needsSave = false;
      bakedGeom = this.bakeInstances(this.featherMesh.geometry, this.instances);
      baked = Geometry.merge(bakedGeom, this.mesh.geometry);
      return ObjWriter.save(baked, 'Instancanae_' + Date.now() + '.obj');
    },
    bakeInstances: function(baseGeom, instances) {
      var copy, empty, geom, i, instance, v, _i, _j, _len, _len1, _ref7;

      empty = new Geometry({
        vertices: [],
        faces: [],
        normals: []
      });
      geom = empty;
      for (i = _i = 0, _len = instances.length; _i < _len; i = ++_i) {
        instance = instances[i];
        console.log(i, '/', instances.length);
        copy = Geometry.merge(empty, baseGeom);
        _ref7 = copy.vertices;
        for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
          v = _ref7[_j];
          v.x *= instance.scale.x;
          v.y *= instance.scale.y;
          v.z *= instance.scale.z;
        }
        copy.rotate(instance.rotation);
        copy.translate(instance.position);
        geom = Geometry.merge(geom, copy);
      }
      return geom;
    },
    draw: function() {
      var normals;

      this.gl.clearColor(0.2, 0.26, 0.3, 1.0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      this.gl.enable(this.gl.DEPTH_TEST);
      seed(0);
      normals = this.body.normals;
      this.instances = this.anchorPoints.map(function(p, pi) {
        var dir, instance, s, s2, speed;

        s = 0.5;
        s2 = 0.5 + randomFloat() * 0.5;
        dir = new Vec3(p.x, 0.5, p.z);
        speed = 3;
        dir.y += 0.2 * sin(Time.seconds * speed + p.y * 2);
        dir.x += 0.2 * sin(Time.seconds * speed + p.y * 2);
        return instance = {
          position: p,
          scale: new Vec3(s, s, s2),
          rotation: Quat.fromDirection(dir)
        };
      });
      if (this.needsSave) {
        this.save();
      }
      this.mesh.draw(this.camera);
      return this.featherMesh.drawInstances(this.camera, this.instances);
    }
  });
});

/*
//@ sourceMappingURL=Instancanae.map
*/
