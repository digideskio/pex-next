// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Agent, AnimatedFloat, AnimatedVec3, Arcball, Color, Config, Context, Cube, Cylinder, Diffuse, Dodecahedron, Edge, Face3, Gene, Geometry, Grass, Icosahedron, LineBuilder, Loft, Mat4, MathUtils, Mesh, Octahedron, PI, PerspectiveCamera, Plane, Platform, RenderTarget, Scene, ScreenImage, ShowColors, ShowDepth, ShowNormals, SolidColor, Sphere, Spline1D, Spline3D, Texture2D, Time, Vec2, Vec3, Viewport, Window, abs, cos, exp, floor, gh, hem, lerp, log, map, max, min, pex, random, randomFloat, randomVec3, seed, shuffle, sin, sqrt, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals, ShowColors = _ref2.ShowColors;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage, Context = _ref3.Context;
  _ref4 = pex.geom, hem = _ref4.hem, Vec2 = _ref4.Vec2, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, Edge = _ref4.Edge, Mat4 = _ref4.Mat4, Spline3D = _ref4.Spline3D, Face3 = _ref4.Face3;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere, Dodecahedron = _ref5.Dodecahedron, Icosahedron = _ref5.Icosahedron, LineBuilder = _ref5.LineBuilder, Plane = _ref5.Plane;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils;
  map = MathUtils.map, seed = MathUtils.seed, randomVec3 = MathUtils.randomVec3, randomFloat = MathUtils.randomFloat;
  cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, floor = Math.floor, min = Math.min, max = Math.max, exp = Math.exp, log = Math.log;
  Agent = require('flora/growth/Agent');
  Cylinder = require('geom/gen/Cylinder');
  Plane = require('geom/Plane');
  Loft = require('geom/Loft');
  Spline1D = require('geom/Spline1D');
  Gene = require('flora/plants/Gene');
  gh = require('geom/gh');
  AnimatedVec3 = require('flora/growth/AnimatedVec3');
  AnimatedFloat = require('flora/growth/AnimatedFloat');
  Config = require('flora/game/Config');
  lerp = function(va, vb, t) {
    return Vec3.create(va.x + (vb.x - va.x) * t, va.y + (vb.y - va.y) * t, va.z + (vb.z - va.z) * t);
  };
  shuffle = function(list) {
    var a, b, i, tmp, _i, _ref7;

    for (i = _i = 0, _ref7 = list.length; 0 <= _ref7 ? _i < _ref7 : _i > _ref7; i = 0 <= _ref7 ? ++_i : --_i) {
      a = floor(random() * list.length);
      b = floor(random() * list.length);
      tmp = list[a];
      list[a] = list[b];
      list[b] = tmp;
    }
    return list;
  };
  return Grass = (function() {
    function Grass(app) {
      var UP;

      this.app = app;
      this.type = 'grass';
      this.gl = Context.currentContext.gl;
      this.camera = new PerspectiveCamera(60, this.app.width / this.app.height, 0.5, 5);
      if (this.app.on) {
        this.arcball = new Arcball(this.app, this.camera, 2.5);
      }
      UP = new Vec3(0, 1, 0);
      this.solidMaterial = new SolidColor({
        color: Color.Black
      });
      this.linesMaterial = new SolidColor({
        color: new Color(0.2, 0.3, 0.5, 1.0)
      });
      this.dotsMaterial = new SolidColor({
        color: Config.colors.gold,
        pointSize: 3
      });
      this.highlightsMaterial = new SolidColor({
        color: Config.colors.yellow
      });
      this.darkGoldMaterial = new SolidColor({
        color: Config.secondaryColors.yellow
      });
      this.geom = new Cube(0.5, 0.02, 0.15, 3, 3, 3);
      this.geom = hem().fromGeometry(this.geom).selectFacesBy(function(face) {
        return face.getNormal().dot(UP) === 1;
      });
      this.geom.subdivideFaceCenter().pull(1);
      this.geom = this.geom.toFlatGeometry();
      this.geom = new Cube(0.01);
      this.mesh = new Mesh(this.geom, this.linesMaterial, {
        useEdges: true
      });
      this.lineBuilder = new LineBuilder();
      this.linesMesh = new Mesh(this.lineBuilder, new ShowColors(), {
        primitiveType: this.gl.LINES
      });
      this.genes = {
        height: new Gene('height', 1, 0.2, 2, {
          enabled: false
        }),
        numLeaves: new Gene('numLeaves', 3, 0, 20, {
          type: 'int'
        }),
        spread: new Gene('spread', 0.4, 0.1, 1, {
          enabled: false
        }),
        distribution: new Gene('distribution', 0.2, 0, 1, {
          enabled: true
        }),
        gravity: new Gene('gravity', -0.3, -0, -2, {
          enabled: false
        }),
        numLeafSegments: new Gene('numLeafSegments', 5, 3, 10, {
          enabled: false
        }),
        initialGrowthSpeed: new Gene('initialGrowthSpeed', 1, 0.5, 5, {
          enabled: false
        }),
        numFlowers: new Gene('numFlowers', 5, 0, 20, {
          enabled: false
        }),
        scale: new Gene('scale', 2.5, 0.9, 2.5, {
          enabled: true
        }),
        bulb: new Gene('bulb', 0.1, 0.0, 1, {
          enabled: true
        }),
        leafHoles: new Gene('leafHoles', 0.0, 0.0, 1, {
          enabled: true
        }),
        shape: new Gene('shape', 0.0, 0.0, 1, {
          enabled: true
        })
      };
      this.globeGeom = new HexSphere(6);
      this.globeGeom = hem().fromGeometry(this.globeGeom).triangulate().toFlatGeometry();
      this.globeGeom.computeEdges();
      this.globe = new Mesh(this.globeGeom, this.darkGoldMaterial, {
        useEdges: true
      });
      this.scene = new Scene();
      this.hightlightsScene = new Scene();
      this.buildGUI();
      this.rebuild();
    }

    Grass.prototype.buildGUI = function() {
      var gene, geneName, _ref7, _results,
        _this = this;

      if (!this.app.gui) {
        return;
      }
      _ref7 = this.genes;
      _results = [];
      for (geneName in _ref7) {
        gene = _ref7[geneName];
        if (gene.options.enabled) {
          _results.push(this.app.gui.addParam(gene.name, gene, "normalizedValue", null, function() {
            return _this.dirty = true;
          }));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Grass.prototype.rebuild = function() {
      var agent, circle, circlePoints, distribution, distributionRadius, gravity, height, initialGrowthSpeed, initialNormal, leaf, leafHightlights, leafShapeFuncU, leafShapeFuncV, numFlowers, numLeafSegments, numLeaves, numStems, right, scale, spread, start, startPosition, startPositionIndex, step, steps, tip, _i, _j, _k, _len, _len1, _ref7, _ref8, _ref9, _results, _results1;

      this.dirty = false;
      seed(Time.seconds);
      this.lineBuilder.reset();
      start = new Vec3(0, 0, 0);
      spread = this.genes.spread.value;
      numLeaves = this.genes.numLeaves.value;
      height = this.genes.height.value;
      gravity = this.genes.gravity.value;
      numLeafSegments = this.genes.numLeafSegments.value;
      initialGrowthSpeed = this.genes.initialGrowthSpeed.value;
      numFlowers = this.genes.numFlowers.value;
      distribution = this.genes.distribution.value;
      scale = this.genes.scale.value;
      numStems = 3;
      distributionRadius = 2;
      leafShapeFuncU = new Spline1D([0.1 / 5, 0.2 / 5, 0.01 / 5]);
      leafShapeFuncV = new Spline1D([0.1 / 5, 0.1 / 10, 0]);
      circle = gh.circle(gh.point(0, height, 0), spread);
      circlePoints = shuffle(gh.flatten(gh.divide(circle, this.genes.numLeaves.max)));
      if (!this.startPositions) {
        this.startPositions = (function() {
          _results = [];
          for (var _i = 0, _ref7 = this.genes.numLeaves.max; 0 <= _ref7 ? _i < _ref7 : _i > _ref7; 0 <= _ref7 ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this).map(function() {
          return new AnimatedVec3(new Vec3(randomFloat(-distributionRadius / 2, distributionRadius / 2), 0, randomFloat(-distributionRadius / 2, distributionRadius / 2)));
        });
      }
      _ref8 = this.startPositions;
      for (startPositionIndex = _j = 0, _len = _ref8.length; _j < _len; startPositionIndex = ++_j) {
        startPosition = _ref8[startPositionIndex];
        startPosition.target.copy(startPosition.initialValue).scale(distribution);
        startPosition.target.copy(startPosition.initialValue).scale(distribution);
        startPosition.update();
        this.lineBuilder.addCross(circlePoints[startPositionIndex], 0.05, Color.Red);
      }
      _ref9 = this.startPositions;
      _results1 = [];
      for (startPositionIndex = _k = 0, _len1 = _ref9.length; _k < _len1; startPositionIndex = ++_k) {
        startPosition = _ref9[startPositionIndex];
        if (startPositionIndex < numLeaves) {
          if (!startPosition.leafStemSpline) {
            tip = circlePoints[startPositionIndex].dup();
            agent = new Agent(new Vec3(0, 0, 0));
            agent.velocity = tip.dup().normalize().scale(height);
            agent.velocity.y -= random() * 0.5;
            agent.forces.push(new Vec3(0, gravity, 0));
            agent.updateSteps(numLeafSegments, 1 / numLeafSegments);
            steps = gh.flatten(gh.splitPolylineSegments(gh.polyline(agent.points)));
            startPosition.leafStemSpline = new Spline3D(agent.points);
            startPosition.leafStemSplineSteps = steps;
            initialNormal = circlePoints[startPositionIndex].dup().normalize();
            right = Vec3.create().asCross(initialNormal, new Vec3(initialNormal.x, 0, initialNormal.z).normalize());
            startPosition.initialNormal = Vec3.create().asCross(initialNormal, right);
            startPosition.scale = new AnimatedFloat(0, randomFloat(0, 0.5));
          }
          if (!startPosition.linesMesh) {
            leaf = new Loft(startPosition.leafStemSpline, {
              numSteps: 10,
              ru: leafShapeFuncU,
              rv: leafShapeFuncV,
              initialNormal: startPosition.initialNormal
            });
            leafHightlights = new Geometry({
              vertices: true,
              faces: true
            });
            leaf.vertices.map(function(v) {
              return leafHightlights.vertices.push(v.dup());
            });
            leaf.faces.filter(function(f, fi) {
              return fi % 19 === 0;
            }).map(function(f, fi) {
              return leafHightlights.faces.push(new Face3(f.a, f.b, f.c));
            });
            startPosition.linesMesh = new Mesh(leaf, this.linesMaterial, {
              primitiveType: this.gl.LINES
            });
            startPosition.hightlightsMesh = new Mesh(leafHightlights, this.highlightsMaterial);
            this.scene.add(startPosition.linesMesh);
            this.hightlightsScene.add(startPosition.hightlightsMesh);
          }
          startPosition.linesMesh.position = startPosition.value.dup().add(new Vec3(0, -0.5, 0));
          startPosition.hightlightsMesh.position = startPosition.value.dup().add(new Vec3(0, -0.5, 0));
          startPosition.scale.target = scale;
          startPosition.scale.update();
          startPosition.linesMesh.scale.set(startPosition.scale.value, startPosition.scale.value, startPosition.scale.value);
          startPosition.hightlightsMesh.scale.set(startPosition.scale.value, startPosition.scale.value, startPosition.scale.value);
          _results1.push((function() {
            var _l, _len2, _ref10, _results2;

            _ref10 = startPosition.leafStemSplineSteps;
            _results2 = [];
            for (_l = 0, _len2 = _ref10.length; _l < _len2; _l++) {
              step = _ref10[_l];
              this.lineBuilder.addLine(step.from.dup().add(startPosition.value), step.to.dup().add(startPosition.value));
              _results2.push(this.lineBuilder.addCross(step.to.dup().add(startPosition.value), 0.05, Color.Red));
            }
            return _results2;
          }).call(this));
        } else {
          startPosition.leafStemSpline = null;
          if (startPosition.linesMesh) {
            startPosition.scale.target = 0;
            startPosition.scale.update();
            startPosition.linesMesh.scale.set(startPosition.scale.value, startPosition.scale.value, startPosition.scale.value);
            if (startPosition.scale.value < 0.01) {
              this.scene.remove(startPosition.linesMesh);
              _results1.push(startPosition.linesMesh = null);
            } else {
              _results1.push(void 0);
            }
          } else {
            _results1.push(void 0);
          }
        }
      }
      return _results1;
    };

    Grass.prototype.update = function() {
      return this.rebuild();
    };

    Grass.prototype.draw = function(perspectiveCamera) {
      var camera, d, _i, _j, _len, _len1, _ref7, _ref8;

      camera = perspectiveCamera || this.camera;
      this.update();
      this.gl.depthRange(0.001, 1.0);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.enable(this.gl.CULL_FACE);
      this.gl.cullFace(this.gl.FRONT);
      _ref7 = this.scene.drawables;
      for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
        d = _ref7[_i];
        d.setMaterial(this.solidMaterial);
        d.primitiveType = this.gl.TRIANGLES;
        d.draw(this.camera);
        d.setMaterial(this.linesMaterial);
        this.gl.lineWidth(2);
        d.primitiveType = this.gl.LINES;
        d.draw(this.camera);
        d.setMaterial(this.dotsMaterial);
        d.primitiveType = this.gl.POINTS;
      }
      this.gl.depthRange(0.0, 0.998);
      _ref8 = this.hightlightsScene.drawables;
      for (_j = 0, _len1 = _ref8.length; _j < _len1; _j++) {
        d = _ref8[_j];
        d.draw(this.camera);
      }
      this.gl.disable(this.gl.CULL_FACE);
      return this.globe.draw(camera);
    };

    return Grass;

  })();
});

/*
//@ sourceMappingURL=Grass.map
*/
