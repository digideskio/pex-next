// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Agent, AnimatedFloat, AnimatedVec3, Arcball, CameraOrbiterTouch, Color, Config, Context, Cube, Cylinder, Diffuse, Dodecahedron, Edge, Face3, GUI, Gene, GeomExtensions, Geometry, Grass, HexSphere, Icosahedron, Instance, LineBuilder, Loft, Mat4, MathUtils, Mesh, Octahedron, PI, PerspectiveCamera, Plane, Platform, Quat, RenderTarget, Scene, ScreenImage, ShowColors, ShowDepth, ShowNormals, SolidColor, Sphere, Spline1D, Spline3D, Texture2D, Time, Timeline, UP, Vec2, Vec3, Viewport, Window, abs, cos, exp, floor, gh, hem, lerp, log, map, max, min, pex, random, randomFloat, randomVec3, seed, shuffle, sin, sqrt, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  pex = require('pex');
  _ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform;
  _ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;
  _ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals, ShowColors = _ref2.ShowColors;
  _ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage, Context = _ref3.Context;
  _ref4 = pex.geom, hem = _ref4.hem, Vec2 = _ref4.Vec2, Vec3 = _ref4.Vec3, Geometry = _ref4.Geometry, Edge = _ref4.Edge, Mat4 = _ref4.Mat4, Spline3D = _ref4.Spline3D, Face3 = _ref4.Face3, Quat = _ref4.Quat, hem = _ref4.hem;
  _ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere, Dodecahedron = _ref5.Dodecahedron, Icosahedron = _ref5.Icosahedron, LineBuilder = _ref5.LineBuilder, Plane = _ref5.Plane, HexSphere = _ref5.HexSphere;
  Color = pex.color.Color;
  _ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils;
  map = MathUtils.map, seed = MathUtils.seed, randomVec3 = MathUtils.randomVec3, randomFloat = MathUtils.randomFloat;
  GUI = require('pex/gui').GUI;
  cos = Math.cos, sin = Math.sin, PI = Math.PI, sqrt = Math.sqrt, abs = Math.abs, random = Math.random, floor = Math.floor, min = Math.min, max = Math.max, exp = Math.exp, log = Math.log;
  Agent = require('flora/growth/Agent');
  Cylinder = require('geom/gen/Cylinder');
  Plane = require('geom/Plane');
  Loft = require('geom/Loft');
  Spline1D = require('geom/Spline1D');
  Gene = require('flora/plants/Gene');
  gh = require('geom/gh');
  AnimatedVec3 = require('flora/growth/AnimatedVec3');
  AnimatedFloat = require('flora/growth/AnimatedFloat');
  Config = require('flora/game/Config');
  GeomExtensions = require('geom/Extensions');
  Timeline = require('lib/timeline').Timeline;
  CameraOrbiterTouch = require('utils/CameraOrbiterTouch');
  Instance = require('flora/plants/Instance');
  lerp = function(va, vb, t) {
    return Vec3.create(va.x + (vb.x - va.x) * t, va.y + (vb.y - va.y) * t, va.z + (vb.z - va.z) * t);
  };
  shuffle = function(list) {
    var a, b, i, tmp, _i, _ref7;

    for (i = _i = 0, _ref7 = list.length; 0 <= _ref7 ? _i < _ref7 : _i > _ref7; i = 0 <= _ref7 ? ++_i : --_i) {
      a = floor(random() * list.length);
      b = floor(random() * list.length);
      tmp = list[a];
      list[a] = list[b];
      list[b] = tmp;
    }
    return list;
  };
  UP = new Vec3(0, 1, 0);
  return Grass = (function() {
    function Grass(app) {
      this.app = app;
      this.type = 'grass';
      Time.verbose = true;
      this.gl = Context.currentContext.gl;
      this.camera = new PerspectiveCamera(60, this.app.width / this.app.height, 0.25, 10);
      if (this.app.on) {
        this.cameraController = new CameraOrbiterTouch(this.app, this.camera, 2.5, 45);
      }
      this.genes = {
        numLeaves: new Gene('numLeaves', 5, 0, 20, {
          type: 'int'
        }),
        pliability: new Gene('pliability', 1, 0, 2),
        distribution: new Gene('distribution', 0.2, 0, 1),
        scale: new Gene('scale', 1.2, 0.5, 2),
        bulb: new Gene('bulb', 0.07, 0.02, 0.15),
        shape: new Gene('shape', 1, 0, 1),
        leafHoles: new Gene('leafHoles', 0.0, 0.0, 1),
        height: new Gene('height', 1, 0.2, 2),
        spread: new Gene('spread', 0.4, 0.1, 1),
        gravity: new Gene('gravity', -0.3, -0, -2),
        numLeafSegments: new Gene('numLeafSegments', 5, 3, 10),
        initialGrowthSpeed: new Gene('initialGrowthSpeed', 1, 0.5, 5),
        numFlowers: new Gene('numFlowers', 5, 0, 20),
        bulbsPerLeaf: new Gene('bulbsPerLeaf', 5, 1, 5, {
          type: 'int'
        })
      };
      this.buildGUI();
      this.buildMaterials();
      this.buildMeshes();
      this.buildInstances();
    }

    Grass.prototype.buildMaterials = function() {
      this.fillMaterial = new SolidColor({
        color: new Color(0.03, 0.03, 0.03, 1.0)
      });
      this.fillMaterial2 = new SolidColor({
        color: Config.colors.yellow
      });
      this.edgesMaterial = new SolidColor({
        color: Config.colors.yellow
      });
      this.edgesMaterial2 = new SolidColor({
        color: Config.colors.orange
      });
      this.dotsMaterial = new SolidColor({
        color: Config.colors.gold,
        pointSize: 2
      });
      this.highlightsMaterial = new SolidColor({
        color: Config.colors.yellow
      });
      return this.darkGoldMaterial = new SolidColor({
        color: Config.secondaryColors.yellow
      });
    };

    Grass.prototype.buildMeshes = function() {
      this.leafCellGeom = new Cube(1, 1, 1);
      this.leafCellGeom = hem().fromGeometry(this.leafCellGeom);
      this.leafCellGeom.vertices[0].sharp = true;
      this.leafCellGeom.vertices[1].sharp = true;
      this.leafCellGeom.vertices[2].sharp = true;
      this.leafCellGeom.vertices[3].sharp = true;
      this.leafCellGeom = this.leafCellGeom.subdivide().toFlatGeometry();
      this.leafCellGeom.translate(new Vec3(0, 0, 0.5));
      this.leafCellGeom.computeEdges();
      this.leafCellMesh = new Mesh(this.leafCellGeom, this.fillMaterial2);
      this.leafCellEdgesMesh = new Mesh(this.leafCellGeom, this.edgesMaterial2, {
        useEdges: true
      });
      this.leafCellDotsMesh = new Mesh(this.leafCellGeom, this.dotsMaterial, {
        primitiveType: this.gl.POINTS
      });
      this.bulbGeom = new Dodecahedron();
      this.bulbGeom = hem().fromGeometry(this.bulbGeom).triangulate().toFlatGeometry();
      this.bulbMesh = new Mesh(this.bulbGeom, this.fillMaterial);
      this.bulbEdgesMesh = new Mesh(this.bulbGeom, this.edgesMaterial, {
        useEdges: true
      });
      this.stemGeom = new Cube(1, 1, 1);
      this.stemGeom = hem().fromGeometry(this.stemGeom);
      this.stemGeom.faces[0].edgePairLoop(function(edge) {
        return edge.sharp = true;
      });
      this.stemGeom.faces[1].edgePairLoop(function(edge) {
        return edge.sharp = true;
      });
      this.stemGeom = this.stemGeom.subdivide().toFlatGeometry();
      this.stemGeom.translate(new Vec3(0, 0, 0.5));
      this.stemGeom.computeEdges();
      this.stemMesh = new Mesh(this.stemGeom, this.fillMaterial);
      this.stemEdgesMesh = new Mesh(this.stemGeom, this.edgesMaterial, {
        useEdges: true
      });
      this.globeGeom = new HexSphere(6);
      this.globeGeom = hem().fromGeometry(this.globeGeom).triangulate().toFlatGeometry();
      this.globeGeom.computeEdges();
      return this.globe = new Mesh(this.globeGeom, this.darkGoldMaterial, {
        useEdges: true
      });
    };

    Grass.prototype.buildInstances = function() {
      var _i, _j, _k, _ref7, _results, _results1, _results2;

      this.leafInstances = (function() {
        _results = [];
        for (_i = 0; _i < 200; _i++){ _results.push(_i); }
        return _results;
      }).apply(this).map(function() {
        return new Instance(2.5);
      });
      this.bulbInstances = (function() {
        _results1 = [];
        for (var _j = 0, _ref7 = this.genes.numLeaves.max * this.genes.bulbsPerLeaf.max; 0 <= _ref7 ? _j < _ref7 : _j > _ref7; 0 <= _ref7 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).map(function() {
        return new Instance(2.5);
      });
      return this.stemInstances = (function() {
        _results2 = [];
        for (_k = 0; _k < 50; _k++){ _results2.push(_k); }
        return _results2;
      }).apply(this).map(function() {
        return new Instance(2.5);
      });
    };

    Grass.prototype.buildGUI = function() {
      var gene, geneName, _ref7, _results,
        _this = this;

      if (!this.app.gui) {
        return;
      }
      _ref7 = this.genes;
      _results = [];
      for (geneName in _ref7) {
        gene = _ref7[geneName];
        if (gene.options.enabled) {
          _results.push(this.app.gui.addParam(gene.name, gene, "normalizedValue", null, function() {
            return _this.dirty = true;
          }));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Grass.prototype.rebuild = function() {
      var basePos, bendAxis, bendRot, bulbIndex, bulbsPerLeaf, circle, dirRot, direction, distribution, distributionRadius, gravity, height, i, initialGrowthSpeed, instanceIndex, instancePliability, instanceScape, leafIndex, leafSegmentIndex, leafShapeFuncU, leafShapeFuncV, numFlowers, numLeafSegments, numLeaves, numStems, pliability, pos, scale, segmentScale, shape, spread, start, sx, sy, sz, _i, _j, _k, _l, _m, _n, _o, _p, _q, _ref10, _ref11, _ref12, _ref7, _ref8, _ref9, _results, _results1;

      this.dirty = false;
      start = new Vec3(0, 0, 0);
      spread = this.genes.spread.value;
      numLeaves = floor(this.genes.numLeaves.value);
      height = this.genes.height.value;
      gravity = this.genes.gravity.value;
      numLeafSegments = this.genes.numLeafSegments.value;
      initialGrowthSpeed = this.genes.initialGrowthSpeed.value;
      numFlowers = this.genes.numFlowers.value;
      distribution = this.genes.distribution.value;
      scale = this.genes.scale.value;
      shape = this.genes.shape.value;
      pliability = this.genes.pliability.value;
      bulbsPerLeaf = floor(this.genes.bulbsPerLeaf.value);
      numStems = 3;
      distributionRadius = 2;
      numLeafSegments = 7;
      leafShapeFuncU = new Spline1D([0.1 / 5, 0.2 / 5, 0.01 / 5]);
      leafShapeFuncV = new Spline1D([0.1 / 5, 0.1 / 10, 0]);
      circle = gh.circle(gh.point(0, height, 0), spread);
      if (!this.circlePoints) {
        this.circlePoints = shuffle(gh.flatten(gh.divide(circle, this.genes.numLeaves.max)));
      }
      if (!this.startPositions) {
        this.startPositions = (function() {
          _results = [];
          for (var _i = 0, _ref7 = this.genes.numLeaves.max; 0 <= _ref7 ? _i < _ref7 : _i > _ref7; 0 <= _ref7 ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this).map(function() {
          return new Vec3(randomFloat(-distributionRadius / 2, distributionRadius / 2), -1, randomFloat(-distributionRadius / 2, distributionRadius / 2));
        });
      }
      seed(0);
      instanceIndex = 0;
      for (leafIndex = _j = 0; 0 <= numLeaves ? _j < numLeaves : _j > numLeaves; leafIndex = 0 <= numLeaves ? ++_j : --_j) {
        instancePliability = pliability * randomFloat(0.5, 1) + 0.1 * sin(Time.seconds + (leafIndex * PI) % 2.12);
        instanceScape = scale;
        basePos = this.startPositions[leafIndex].dup().scale(distribution);
        pos = this.startPositions[leafIndex].dup().scale(distribution);
        bendAxis = new Vec3(0, 0, 1).transformQuat(Quat.create().setAxisAngle(UP, randomFloat(0, 360)));
        bendRot = Quat.create().setAxisAngle(bendAxis, instancePliability * 10);
        direction = new Vec3(0, 1, 0);
        for (bulbIndex = _k = 0; 0 <= bulbsPerLeaf ? _k < bulbsPerLeaf : _k > bulbsPerLeaf; bulbIndex = 0 <= bulbsPerLeaf ? ++_k : --_k) {
          this.bulbInstances[leafIndex * bulbsPerLeaf + bulbIndex].targetScale.set(this.genes.bulb.value, this.genes.bulb.value, this.genes.bulb.value);
          this.bulbInstances[leafIndex * bulbsPerLeaf + bulbIndex].targetPosition.set(basePos.x, basePos.y - this.genes.bulb.value / 2, basePos.z).add(randomVec3().scale(this.genes.bulb.value));
        }
        for (leafSegmentIndex = _l = 0; 0 <= numLeafSegments ? _l < numLeafSegments : _l > numLeafSegments; leafSegmentIndex = 0 <= numLeafSegments ? ++_l : --_l) {
          direction.transformQuat(bendRot);
          dirRot = Quat.fromDirection(direction);
          segmentScale = 1.1 - Timeline.Easing.Cubic.EaseInOut(leafSegmentIndex / numLeafSegments);
          sx = instanceScape * 0.1 * segmentScale;
          sy = instanceScape * 0.1 / 4 * segmentScale;
          sz = instanceScape * 0.1 * segmentScale;
          if (shape > 0.5) {
            sx *= map(shape, 0.5, 1, 1, 0.5);
            sz *= map(shape, 0.5, 1, 1, 2);
          } else {
            sx *= map(shape, 0, 0.5, 1.5, 1);
            sz *= map(shape, 0, 0.5, 0.75, 1);
          }
          this.leafInstances[instanceIndex].targetScale.set(sx, sy, sz);
          this.leafInstances[instanceIndex].targetPosition.setVec3(pos);
          this.leafInstances[instanceIndex].targetRotation.copy(dirRot);
          pos.addScaled(direction, sz * 0.9);
          instanceIndex++;
        }
      }
      for (i = _m = instanceIndex, _ref8 = this.leafInstances.length; instanceIndex <= _ref8 ? _m < _ref8 : _m > _ref8; i = instanceIndex <= _ref8 ? ++_m : --_m) {
        this.leafInstances[i].targetScale.set(0, 0, 0);
      }
      instanceIndex = 0;
      for (leafIndex = _n = 0; 0 <= numLeaves ? _n < numLeaves : _n > numLeaves; leafIndex = 0 <= numLeaves ? ++_n : --_n) {
        if (leafIndex % 2 === 0) {
          continue;
        }
        instancePliability = pliability * randomFloat(0.5, 1) + 0.1 * sin(Time.seconds + (leafIndex * PI) % 2.12);
        instancePliability /= 4;
        instanceScape = scale;
        basePos = this.startPositions[leafIndex].dup().scale(distribution);
        pos = this.startPositions[leafIndex].dup().scale(distribution);
        bendAxis = new Vec3(0, 0, 1).transformQuat(Quat.create().setAxisAngle(UP, randomFloat(0, 360)));
        bendRot = Quat.create().setAxisAngle(bendAxis, instancePliability * 10);
        direction = new Vec3(0, 1, 0);
        for (leafSegmentIndex = _o = 0, _ref9 = numLeafSegments / 2; 0 <= _ref9 ? _o < _ref9 : _o > _ref9; leafSegmentIndex = 0 <= _ref9 ? ++_o : --_o) {
          direction.transformQuat(bendRot);
          dirRot = Quat.fromDirection(direction);
          segmentScale = 1.1 - Timeline.Easing.Cubic.EaseInOut(leafSegmentIndex / numLeafSegments);
          segmentScale /= 2;
          sx = instanceScape * 0.025 * segmentScale;
          sy = instanceScape * 0.025 * segmentScale;
          sz = instanceScape * 0.5 * segmentScale;
          if (!this.stemInstances[instanceIndex]) {
            continue;
          }
          this.stemInstances[instanceIndex].targetScale.set(sx, sy, sz);
          this.stemInstances[instanceIndex].targetPosition.setVec3(pos);
          this.stemInstances[instanceIndex].targetRotation.copy(dirRot);
          pos.addScaled(direction, sz);
          instanceIndex++;
        }
      }
      for (i = _p = instanceIndex, _ref10 = this.stemInstances.length; instanceIndex <= _ref10 ? _p < _ref10 : _p > _ref10; i = instanceIndex <= _ref10 ? ++_p : --_p) {
        this.stemInstances[i].targetScale.set(0, 0, 0);
      }
      _results1 = [];
      for (i = _q = _ref11 = numLeaves * bulbsPerLeaf, _ref12 = this.genes.numLeaves.max * bulbsPerLeaf; _ref11 <= _ref12 ? _q < _ref12 : _q > _ref12; i = _ref11 <= _ref12 ? ++_q : --_q) {
        _results1.push(this.bulbInstances[i].targetScale.set(0, 0, 0));
      }
      return _results1;
    };

    Grass.prototype.animateInstances = function(instances) {
      var instance, instanceIndex, _i, _len, _results;

      _results = [];
      for (instanceIndex = _i = 0, _len = instances.length; _i < _len; instanceIndex = ++_i) {
        instance = instances[instanceIndex];
        _results.push(instance.update());
      }
      return _results;
    };

    Grass.prototype.update = function() {
      if (this.cameraController) {
        this.cameraController.update();
      }
      if (Time.frameNumber % 5 === 0) {
        this.rebuild();
      }
      this.animateInstances(this.leafInstances);
      this.animateInstances(this.bulbInstances);
      return this.animateInstances(this.stemInstances);
    };

    Grass.prototype.draw = function(perspectiveCamera) {
      var bulbsPerLeaf, camera, numLeaves;

      camera = perspectiveCamera || this.camera;
      this.update();
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.enable(this.gl.CULL_FACE);
      this.gl.disable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
      this.globe.draw(camera);
      numLeaves = floor(this.genes.numLeaves.value);
      bulbsPerLeaf = floor(this.genes.bulbsPerLeaf.value);
      this.gl.lineWidth(1);
      this.leafCellMesh.drawInstances(camera, this.leafInstances, numLeaves);
      this.stemMesh.drawInstances(camera, this.stemInstances, numLeaves);
      this.bulbMesh.drawInstances(camera, this.bulbInstances, numLeaves * bulbsPerLeaf);
      this.leafCellEdgesMesh.drawInstances(camera, this.leafInstances, numLeaves);
      this.bulbEdgesMesh.drawInstances(camera, this.bulbInstances, numLeaves * bulbsPerLeaf);
      this.stemEdgesMesh.drawInstances(camera, this.stemInstances, numLeaves);
      this.leafCellDotsMesh.drawInstances(camera, this.leafInstances, numLeaves);
      return this.gl.disable(this.gl.CULL_FACE);
    };

    return Grass;

  })();
});

/*
//@ sourceMappingURL=GrassInstanced.map
*/
