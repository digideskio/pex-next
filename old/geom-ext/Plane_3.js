// Generated by CoffeeScript 1.6.2
define(function(require) {
  var EPSYLON, Mat4, Plane, Vec2, Vec3, _ref;

  _ref = require('pex/geom'), Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Mat4 = _ref.Mat4;
  EPSYLON = 0.01;
  return Plane = (function() {
    function Plane(point, normal) {
      this.point = point != null ? point : new Vec3(0, 0, 0);
      this.normal = normal != null ? normal : new Vec3(0, 1, 0);
    }

    Plane.prototype.intersectSegment = function(line) {
      var d, hitPoint, lDotN, plDotN;

      plDotN = Vec3.create().asSub(this.point, line.a).dot(this.normal);
      lDotN = line.direction.dot(this.normal);
      if (Math.abs(lDotN) < 0.001) {
        return null;
      }
      d = plDotN / lDotN;
      hitPoint = Vec3.create().copy(line.direction).scale(d).add(line.a);
      hitPoint.ratio = d / line.a.dup().sub(line.b).length();
      return hitPoint;
    };

    Plane.prototype.isPointAbove = function(p) {
      var pp;

      pp = Vec3.create().asSub(p, this.point).normalize();
      return pp.dot(this.normal) > 0;
    };

    Plane.prototype.getBaseVectors = function() {
      var N, U, V, invLength;

      invLength = 0;
      N = this.normal.dup().normalize();
      U = new Vec3();
      if (Math.abs(N.x) > Math.abs(N.y)) {
        U.x = N.z;
        U.y = 0;
        U.z = -N.x;
      } else {
        U.x = 0;
        U.y = N.z;
        U.z = -N.y;
      }
      U.normalize();
      V = Vec3.create().asCross(N, U);
      return {
        up: U,
        right: V,
        front: this.normal
      };
    };

    Plane.prototype.vec3ToVec2 = function(v) {
      var baseVectors, d, m, m4, v2, v2m, v4m;

      baseVectors = this.getBaseVectors();
      d = v.subbed(this.point);
      v2 = new Vec2(baseVectors.right.dot(d), baseVectors.up.dot(d));
      m = Mat3.fromVectorBase(baseVectors.right, baseVectors.up, baseVectors.front);
      v2m = m.mulVec3(d);
      m4 = new Mat4();
      m4.set4x4r(baseVectors.right.x, baseVectors.right.y, baseVectors.right.z, 0, baseVectors.up.x, baseVectors.up.y, baseVectors.up.z, 0, baseVectors.front.x, baseVectors.front.y, baseVectors.front.z, 0, 0, 0, 0, 1);
      v4m = m4.mulVec3(d);
      return v2;
    };

    Plane.prototype.vec2ToVec3 = function(v) {
      var baseVectors, result;

      baseVectors = this.getBaseVectors();
      result = baseVectors.right.dup().scale(v.x).add(baseVectors.up.dup().scale(v.y));
      result.add(this.point);
      return result;
    };

    Plane.prototype.projectPoint = function(a) {
      var pa, paDotN;

      pa = Vec3.create().asSub(a, this.point);
      paDotN = pa.dot(this.normal);
      return a.dup().sub(this.normal.dup().scale(paDotN));
    };

    Plane.prototype.distance = function(a) {
      var projectedA;

      projectedA = this.projectPoint(a);
      return projectedA.distance(a);
    };

    Plane.prototype.contains = function(a) {
      return this.distance(a) < EPSYLON;
    };

    return Plane;

  })();
});

/*
//@ sourceMappingURL=Plane.map
*/
