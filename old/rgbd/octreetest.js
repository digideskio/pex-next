// Generated by CoffeeScript 1.6.2
var Arcball, BoundingBox, Color, Cube, Edge, GUI, Geometry, LineBuilder, Mat4, Mesh, Octree, PerspectiveCamera, Platform, Rect, ShowColors, SkCanvas, SolidColor, Test, Vec2, Vec3, Vec4, floor, max, min, pex, random, rgb2hsl, _ref, _ref1, _ref2, _ref3;

pex = pex || require('./lib/pex');

Platform = pex.sys.Platform;

Mesh = pex.gl.Mesh;

_ref = pex.scene, PerspectiveCamera = _ref.PerspectiveCamera, Arcball = _ref.Arcball;

GUI = pex.gui.GUI;

_ref1 = pex.geom, Vec2 = _ref1.Vec2, Vec3 = _ref1.Vec3, Vec4 = _ref1.Vec4, Mat4 = _ref1.Mat4, Rect = _ref1.Rect, Geometry = _ref1.Geometry, Edge = _ref1.Edge, Octree = _ref1.Octree, BoundingBox = _ref1.BoundingBox;

_ref2 = pex.geom.gen, Cube = _ref2.Cube, LineBuilder = _ref2.LineBuilder;

_ref3 = pex.materials, SolidColor = _ref3.SolidColor, Test = _ref3.Test, ShowColors = _ref3.ShowColors;

SkCanvas = pex.sys.Node.plask.SkCanvas;

Color = pex.color.Color;

min = Math.min, max = Math.max, random = Math.random, floor = Math.floor;

rgb2hsl = function(r, g, b) {
  var cDelta, cMax, cMin, h, l, s;

  h = 0.0;
  s = 0.0;
  l = 0.0;
  cMin = min(r, min(g, b));
  cMax = max(r, max(g, b));
  l = (cMax + cMin) / 2.0;
  if (cMax > cMin) {
    cDelta = cMax - cMin;
    s = l < 0.05 ? cDelta / (cMax + cMin) : cDelta / (2.0 - (cMax + cMin));
    if (r === cMax) {
      h = (g - b) / cDelta;
    } else if (g === cMax) {
      h = 2.0 + (b - r) / cDelta;
    } else {
      h = 4.0 + (r - g) / cDelta;
    }
    if (h < 0.0) {
      h += 6.0;
    }
    h = h / 6.0;
  }
  return new Vec3(h, s, l);
};

pex.require([], function() {
  return pex.sys.Window.create({
    init: function() {
      var avgColor, bbox, bboxSize, canvas, cell, ci, colors, cube, cubeInstance, depth, di, edges, fov, hsl, hsl2depth, i, lineBuilder, maxDepth, maxDist, minDepth, octree, octreeSize, p, v, vertices, x, xyd2xyz, y, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _ref4, _ref5, _ref6, _ref7, _ref8, _results;

      canvas = SkCanvas.createFromImage('assets/save.00411.png');
      cube = new Cube(1);
      this.cube = new Mesh(cube, new SolidColor());
      this.pointsGeometry = new Geometry({
        vertices: true,
        colors: true,
        edges: true
      });
      vertices = this.pointsGeometry.vertices;
      colors = this.pointsGeometry.colors;
      edges = this.pointsGeometry.edges;
      minDepth = 500;
      maxDepth = 2000;
      fov = 1270.34;
      xyd2xyz = function(x, y, d) {
        var v;

        v = new Vec3((x - 320) * d / fov, -(y - 240) * d / fov, -d + 1000);
        return v;
      };
      hsl2depth = function(hsl) {
        var depth;

        depth = hsl.x;
        return depth * (maxDepth - minDepth) + minDepth;
      };
      for (x = _i = 0, _ref4 = canvas.width - 1; _i <= _ref4; x = _i += 2) {
        for (y = _j = 0, _ref5 = canvas.height / 2 - 1; _j <= _ref5; y = _j += 2) {
          di = 4 * (x + (y + canvas.height / 2) * canvas.width);
          ci = 4 * (x + y * canvas.width);
          hsl = rgb2hsl(canvas[di + 2] / 255, canvas[di + 1] / 255, canvas[di + 0] / 255);
          depth = hsl2depth(hsl);
          v = xyd2xyz(x, y, depth);
          if (hsl.y > 0.005) {
            v.color = new Color(canvas[ci + 2] / 255, canvas[ci + 1] / 255, canvas[ci + 0] / 255, 1);
            vertices.push(v);
            colors.push(v.color);
          }
        }
      }
      this.mesh = new Mesh(this.pointsGeometry, new ShowColors({
        pointSize: 2
      }), {
        primitiveType: this.gl.POINTS
      });
      bbox = BoundingBox.fromPoints(vertices);
      bboxSize = bbox.getSize();
      maxDist = Math.max(bboxSize.x, bboxSize.y, bboxSize.z);
      this.camera = new PerspectiveCamera(60, this.width / this.height, maxDist / 10, 2 * maxDist);
      this.arcball = new Arcball(this, this.camera, bbox.max.z + maxDist / 5);
      octreeSize = new Vec3(maxDist, maxDist, maxDist);
      octree = new Octree(bbox.getCenter().clone().sub(octreeSize.dup().scale(0.5)), octreeSize);
      for (_k = 0, _len = vertices.length; _k < _len; _k++) {
        v = vertices[_k];
        octree.add(v);
      }
      lineBuilder = new LineBuilder();
      this.drawCell(octree.root, lineBuilder);
      this.octreeMesh = new Mesh(lineBuilder, new SolidColor({
        color: new Color(0.0, 0.0, 0.3, 1)
      }), {
        useEdges: true
      });
      this.cubes = [];
      _ref6 = this.getAllCellsAtLevel(octree.root, 6);
      for (_l = 0, _len1 = _ref6.length; _l < _len1; _l++) {
        cell = _ref6[_l];
        avgColor = new Color(0, 0, 0, 1);
        _ref7 = cell.points;
        for (_m = 0, _len2 = _ref7.length; _m < _len2; _m++) {
          p = _ref7[_m];
          avgColor.r += p.color.r;
          avgColor.g += p.color.g;
          avgColor.b += p.color.b;
        }
        avgColor.r /= cell.points.length;
        avgColor.g /= cell.points.length;
        avgColor.b /= cell.points.length;
        cubeInstance = {
          position: cell.position.add(cell.size.clone().scale(0.5)),
          scale: cell.size.x,
          color: avgColor
        };
        this.cubes.push(cubeInstance);
      }
      _results = [];
      for (i = _n = 0, _ref8 = Octree.MaxLevel; 0 <= _ref8 ? _n <= _ref8 : _n >= _ref8; i = 0 <= _ref8 ? ++_n : --_n) {
        _results.push(console.log("Octree level " + i, this.getAllCellsAtLevel(octree.root, i).length));
      }
      return _results;
    },
    drawCell: function(cell, lineBuilder) {
      var child, d, h, w, x, y, z, _i, _len, _ref4, _results;

      x = cell.position.x;
      y = cell.position.y;
      z = cell.position.z;
      w = cell.size.x;
      h = cell.size.y;
      d = cell.size.z;
      lineBuilder.addLine(new Vec3(x, y, z), new Vec3(x + w, y, z));
      lineBuilder.addLine(new Vec3(x + w, y, z), new Vec3(x + w, y, z + d));
      lineBuilder.addLine(new Vec3(x + w, y, z + d), new Vec3(x, y, z + d));
      lineBuilder.addLine(new Vec3(x, y, z + d), new Vec3(x, y, z));
      lineBuilder.addLine(new Vec3(x, y, z), new Vec3(x, y + w, z));
      lineBuilder.addLine(new Vec3(x + w, y, z), new Vec3(x + w, y + w, z));
      lineBuilder.addLine(new Vec3(x + w, y, z + d), new Vec3(x + w, y + w, z + d));
      lineBuilder.addLine(new Vec3(x, y, z + d), new Vec3(x, y + w, z + d));
      lineBuilder.addLine(new Vec3(x, y + w, z), new Vec3(x + w, y + w, z));
      lineBuilder.addLine(new Vec3(x + w, y + w, z), new Vec3(x + w, y + w, z + d));
      lineBuilder.addLine(new Vec3(x + w, y + w, z + d), new Vec3(x, y + w, z + d));
      lineBuilder.addLine(new Vec3(x, y + w, z + d), new Vec3(x, y + w, z));
      _ref4 = cell.children;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        child = _ref4[_i];
        _results.push(this.drawCell(child, lineBuilder));
      }
      return _results;
    },
    getAllCellsAtLevel: function(cell, level, result) {
      var child, _i, _len, _ref4;

      result = result || [];
      if (cell.level === level) {
        if (cell.points.length > 0) {
          result.push(cell);
        }
        return result;
      } else {
        _ref4 = cell.children;
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          child = _ref4[_i];
          this.getAllCellsAtLevel(child, level, result);
        }
        return result;
      }
    },
    draw: function() {
      var cubeInstance, _i, _len, _ref4;

      this.gl.clearColor(0, 0, 0, 1);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.lineWidth(2);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      this.mesh.draw(this.camera);
      _ref4 = this.cubes;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        cubeInstance = _ref4[_i];
        this.cube.position = cubeInstance.position;
        this.cube.scale.x = this.cube.scale.y = this.cube.scale.z = cubeInstance.scale;
        this.cube.material.uniforms.color = cubeInstance.color;
        this.cube.draw(this.camera);
      }
      this.gl.enable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE);
      return this.gl.disable(this.gl.BLEND);
    }
  });
});
