// Generated by CoffeeScript 1.6.2
define(function(require) {
  var Context, Platform, Program, RGBDToPosCoverter, RGBDToPosGLSL, RGBDUtilsGLSL, RenderTarget, ScreenImage, Texture2D, Vec2, Vec4, _ref, _ref1;

  RGBDToPosGLSL = require('lib/text!effects/RGBDToPos.glsl');
  RGBDUtilsGLSL = require('lib/text!materials/RGBDUtils.inc.glsl');
  RenderTarget = require('effects/RenderTarget');
  _ref = require('pex/gl'), Texture2D = _ref.Texture2D, ScreenImage = _ref.ScreenImage, Context = _ref.Context, Program = _ref.Program;
  Platform = require('pex/sys').Platform;
  _ref1 = require('pex/geom'), Vec2 = _ref1.Vec2, Vec4 = _ref1.Vec4;
  return RGBDToPosCoverter = (function() {
    RGBDToPosCoverter.prototype.debugMode = false;

    function RGBDToPosCoverter(app, source, boundingBox) {
      var data, floatTexExt, gl, i, internalFormat, uniforms, _i, _ref2;

      this.app = app;
      this.source = source;
      this.boundingBox = boundingBox;
      gl = this.gl = Context.currentContext.gl;
      this.rgbdToPosProgram = new Program(RGBDUtilsGLSL + '\n' + RGBDToPosGLSL);
      this.particlePositions = Texture2D.create(this.source.textureSize.x, this.source.textureSize.y, {
        bpp: 32
      });
      data = new Float32Array(this.source.textureSize.x * this.source.textureSize.y * 4);
      for (i = _i = 0, _ref2 = this.particlePositions.width * this.particlePositions.height * 4 - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        data[i] = 0;
      }
      internalFormat = Platform.isPlask ? 0x8814 : this.gl.RGBA;
      if (Platform.isBrowser) {
        floatTexExt = this.gl.getExtension('OES_texture_float');
      }
      this.particlePositions.bind();
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, this.particlePositions.width, this.particlePositions.height, 0, gl.RGBA, gl.FLOAT, data);
      this.renderTarget = new RenderTarget(this.particlePositions.width, this.particlePositions.height);
      this.fullScreenRect = new ScreenImage(this.source.texture, 0, 0, this.particlePositions.width, this.particlePositions.height, this.particlePositions.width, this.particlePositions.height);
      this.previewImage = new ScreenImage(this.particlePositions, this.app.width - 10 - this.particlePositions.width / 4, 10, this.particlePositions.width / 4, this.particlePositions.height / 4, this.app.width, this.app.height);
      this.uniforms = uniforms = {
        bboxMin: this.source.boundingBox.min,
        bboxMax: this.source.boundingBox.max,
        texture: this.source.texture,
        textureSize: this.source.textureSize,
        inputPositionRect: new Vec4(0, 0, source.depthRect.width, source.depthRect.height),
        depthRect: new Vec4(source.depthRect.x, source.depthRect.y, source.depthRect.width, source.depthRect.height),
        colorRect: new Vec4(source.colorRect.x, source.colorRect.y, source.colorRect.width, source.colorRect.height)
      };
    }

    RGBDToPosCoverter.prototype.updateUniforms = function() {
      var channel, i, uniformValue, unifornName, _i, _len, _ref2, _ref3, _results;

      if (this.source.channels) {
        _ref2 = this.source.channels;
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          channel = _ref2[i];
          this.uniforms['channelMatrix[' + i + ']'] = channel.matrix;
          this.uniforms['channelOffset[' + i + ']'] = channel.offset;
          this.uniforms['channelDepthRange[' + i + ']'] = new Vec2(channel.depthRange.min, channel.depthRange.max);
          this.uniforms['channelEnabled[' + i + ']'] = channel.enabled;
          this.uniforms['channelColor[' + i + ']'] = channel.color;
          this.uniforms['channelFov[' + i + ']'] = channel.fov;
        }
      } else {
        this.uniforms['channelMatrix[0]'] = (new Mat4()).identity();
        this.uniforms['channelOffset[0]'] = new Vec2(0, 0);
        this.uniforms['channelDepthRange[0]'] = new Vec2(source.depthRange.min, source.depthRange.max);
        this.uniforms['channelEnabled[0]'] = true;
        this.uniforms['channelFov[0]'] = source.fov;
      }
      _ref3 = this.uniforms;
      _results = [];
      for (unifornName in _ref3) {
        uniformValue = _ref3[unifornName];
        _results.push(this.fullScreenRect.mesh.material.uniforms[unifornName] = uniformValue);
      }
      return _results;
    };

    RGBDToPosCoverter.prototype.draw = function() {
      this.gl.viewport(0, 0, this.particlePositions.width, this.particlePositions.height);
      this.updateUniforms();
      this.renderTarget.bind(this.particlePositions);
      this.gl.disable(this.gl.DEPTH_TEST);
      this.gl.clearColor(0, 0, 0, 1);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.fullScreenRect.draw(this.source.texture, this.rgbdToPosProgram);
      this.renderTarget.unbind();
      this.gl.viewport(0, 0, this.app.width, this.app.height);
      this.particlePositions.bind();
      if (this.debugMode) {
        return this.previewImage.draw();
      }
    };

    return RGBDToPosCoverter;

  })();
});
