// Generated by CoffeeScript 1.6.2
define(function(require) {
  var BlinnPhong, Context, Cube, Geometry, MathUtils, Mesh, Normals, PanoramicEnvMap, ShowNormals, Texture2D, TextureCube, Vec2, clamp, hem, _ref, _ref1, _ref2, _ref3;

  _ref = require('pex/gl'), Context = _ref.Context, Texture2D = _ref.Texture2D;
  _ref1 = require('pex/geom'), Geometry = _ref1.Geometry, Vec2 = _ref1.Vec2, hem = _ref1.hem;
  _ref2 = require('pex/gl'), Mesh = _ref2.Mesh, TextureCube = _ref2.TextureCube;
  MathUtils = require('pex/utils').MathUtils;
  Cube = require('pex/geom/gen').Cube;
  _ref3 = require('pex/materials'), ShowNormals = _ref3.ShowNormals, BlinnPhong = _ref3.BlinnPhong;
  PanoramicEnvMap = require('materials/PanoramicEnvMap');
  clamp = function(a, min, max) {
    if (a < min) {
      return min;
    }
    if (a > max) {
      return max;
    }
    return a;
  };
  return Normals = (function() {
    Normals.prototype.amount = 1;

    function Normals(app, source, boundingBox, rgbdTexture) {
      var c2, center, geom, geom1, gl, i, m, material, s, _i;

      this.app = app;
      this.source = source;
      this.boundingBox = boundingBox;
      this.rgbdTexture = rgbdTexture;
      gl = this.gl = Context.currentContext.gl;
      s = this.boundingBox.getSize();
      center = this.boundingBox.getCenter();
      this.meshes = [];
      c2 = new Cube(s.z / 10 * (Math.random() * 0.95 + 0.05), s.z / 10 * (Math.random() * 0.25 + 0.75), s.z / 6);
      geom1 = hem().fromGeometry(c2).triangulate().subdivideTriangles().selectRandomVertices(0.35).pull(s.z / 40).toFlatGeometry();
      this.material = material = new PanoramicEnvMap({
        skyBox: 0,
        texture: this.rgbdTexture
      });
      for (i = _i = 0; _i <= 100; i = ++_i) {
        geom = new Cube(s.z / 5 * (Math.random() * 0.9 + 0.1), s.z / 10 * (Math.random() * 0.9 + 0.1), s.z / 10 * (Math.random() * 0.9 + 0.1));
        geom = hem().fromGeometry(geom).triangulate().subdivideTriangles().selectRandomVertices(0.35).pull(s.z / 40).toFlatGeometry();
        m = new Mesh(geom, material);
        m.position = center.clone().add(MathUtils.randomVec3().normalize().scale(MathUtils.randomFloat(s.y * 0.4, s.y * 0.8)));
        m.offset = Math.random() * 0.9;
        this.meshes.push(m);
      }
    }

    Normals.prototype.draw = function(camera) {
      var mesh, scale, _i, _j, _len, _len1, _ref4, _ref5, _results;

      this.gl.enable(this.gl.DEPTH_TEST);
      _ref4 = this.meshes;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        mesh = _ref4[_i];
        scale = clamp(MathUtils.map(this.amount, mesh.offset, mesh.offset + 0.1, 0, 1), 0, 1);
        mesh.scale.set(scale, scale, scale);
        mesh.material.uniforms.eyePos = camera.getPosition();
      }
      _ref5 = this.meshes;
      _results = [];
      for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
        mesh = _ref5[_j];
        _results.push(mesh.draw(camera));
      }
      return _results;
    };

    return Normals;

  })();
});
