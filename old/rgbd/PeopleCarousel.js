// Generated by CoffeeScript 1.6.2
define(function(require) {
  var BoundingBox, BoundingBoxHelper, Color, Context, Cube, Diffuse, Mat4, MathUtils, Mesh, ObjReader, PeopleCarousel, Plane, Quat, RGBDToPosConverter, SolidColor, Texture2D, Textured, Vec3, rayBoxIntersection, _ref, _ref1, _ref2, _ref3;

  _ref = require('pex/gl'), Mesh = _ref.Mesh, Texture2D = _ref.Texture2D, Context = _ref.Context;
  Textured = require('pex/materials').Textured;
  _ref1 = require('pex/geom'), BoundingBox = _ref1.BoundingBox, Vec3 = _ref1.Vec3, Quat = _ref1.Quat, Mat4 = _ref1.Mat4;
  MathUtils = require('pex/utils').MathUtils;
  _ref2 = require('pex/materials'), Diffuse = _ref2.Diffuse, SolidColor = _ref2.SolidColor, Textured = _ref2.Textured;
  _ref3 = require('pex/geom/gen'), Cube = _ref3.Cube, Plane = _ref3.Plane;
  Color = require('pex/color').Color;
  ObjReader = require('utils/ObjReader');
  BoundingBoxHelper = require('helpers/BoundingBoxHelper');
  RGBDToPosConverter = require('effects/RGBDToPosConverter');
  rayBoxIntersection = function(ray, bbox, t0, t1) {
    var tmax, tmin, tymax, tymin, tzmax, tzmin;

    tmin = 0;
    tmax = 0;
    tymin = 0;
    tymax = 0;
    tzmin = 0;
    tzmax = 0;
    if (ray.direction.x >= 0) {
      tmin = (bbox.min.x - ray.origin.x) / ray.direction.x;
      tmax = (bbox.max.x - ray.origin.x) / ray.direction.x;
    } else {
      tmin = (bbox.max.x - ray.origin.x) / ray.direction.x;
      tmax = (bbox.min.x - ray.origin.x) / ray.direction.x;
    }
    if (ray.direction.y >= 0) {
      tymin = (bbox.min.y - ray.origin.y) / ray.direction.y;
      tymax = (bbox.max.y - ray.origin.y) / ray.direction.y;
    } else {
      tymin = (bbox.max.y - ray.origin.y) / ray.direction.y;
      tymax = (bbox.min.y - ray.origin.y) / ray.direction.y;
    }
    if ((tmin > tymax) || (tymin > tmax)) {
      return 0;
    }
    if (tymin > tmin) {
      tmin = tymin;
    }
    if (tymax < tmax) {
      tmax = tymax;
    }
    if (ray.direction.z >= 0) {
      tzmin = (bbox.min.z - ray.origin.z) / ray.direction.z;
      tzmax = (bbox.max.z - ray.origin.z) / ray.direction.z;
    } else {
      tzmin = (bbox.max.z - ray.origin.z) / ray.direction.z;
      tzmax = (bbox.min.z - ray.origin.z) / ray.direction.z;
    }
    if ((tmin > tzmax) || (tzmin > tmax)) {
      return 1;
    }
    if (tzmin > tmin) {
      tmin = tzmin;
    }
    if (tzmax < tmax) {
      tmax = tzmax;
    }
    if (tmin > 0 && tmax > 0) {
      return tmin;
    }
    return -2;
  };
  return PeopleCarousel = (function() {
    PeopleCarousel.prototype.radius = 5000;

    PeopleCarousel.prototype.drawFloor = true;

    PeopleCarousel.prototype.texturedParticles = true;

    PeopleCarousel.prototype.pointSize = 3;

    PeopleCarousel.prototype.cancelNextMouseMove = false;

    function PeopleCarousel(window, sourcesScene) {
      var bboxCenter, floorGeom, floorMaterial, floorThickGeom, numPeople, _i, _results,
        _this = this;

      this.window = window;
      this.sourcesScene = sourcesScene;
      this.gl = Context.currentContext.gl;
      this.camera = null;
      this.people = [];
      this.helpers = [];
      this.selectedModel = null;
      floorMaterial = new Textured({
        texture: Texture2D.load('assets/images/particleGlow.png')
      });
      floorGeom = new Plane(12000, 12000, 30, 30, 'x', 'z');
      floorGeom.computeEdges();
      this.floor = new Mesh(floorGeom, floorMaterial, {
        useEdges: true
      });
      this.floor.position = this.sourcesScene.modelBaseCenter.dup();
      floorThickGeom = new Plane(12000, 12000, 6, 6, 'x', 'z');
      floorThickGeom.computeEdges();
      this.floorThick = new Mesh(floorThickGeom, floorMaterial, {
        useEdges: true
      });
      this.floorThick.position = this.sourcesScene.modelBaseCenter.dup();
      numPeople = 7;
      this.people = (function() {
        _results = [];
        for (var _i = 0; 0 <= numPeople ? _i <= numPeople : _i >= numPeople; 0 <= numPeople ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(i) {
        var bbox, bboxCenter, bboxHelper, center, k, mc, mcb, mr, position, rotation;

        k = i / numPeople;
        position = new Vec3(0, 0, 0);
        position.x += _this.radius * Math.cos(k * Math.PI * 2);
        position.z += _this.radius * Math.sin(k * Math.PI * 2);
        center = _this.sourcesScene.modelCenter;
        mc = Mat4.create().translate(center.x, center.y, center.z);
        mr = (new Quat()).setAxisAngle(new Vec3(0, 1, 0), -360 * k - 90).toMat4();
        mcb = Mat4.create().translate(-center.x, -center.y, -center.z);
        rotation = mc.mul(mr).mul(mcb);
        bboxCenter = position.dup().add(_this.sourcesScene.modelCenter);
        bbox = BoundingBox.fromPositionSize(bboxCenter, new Vec3(1000, 2000, 1000));
        bboxHelper = new BoundingBoxHelper(bbox, Color.Red);
        _this.helpers.push(bboxHelper);
        return {
          sourceId: i,
          position: position,
          rotation: rotation,
          bbox: bbox,
          bboxHelper: bboxHelper
        };
      });
      bboxCenter = this.sourcesScene.modelCenter.dup();
      this.mainBBox = BoundingBox.fromPositionSize(bboxCenter, new Vec3(800, 2000, 800));
      this.mainBBoxHelper = new BoundingBoxHelper(this.mainBBox, Color.Red);
      this.helpers.push(this.mainBBoxHelper);
      this.people.push({
        sourceId: -1,
        bbox: this.mainBBox,
        bboxHelper: this.mainBBoxHelper
      });
      this.window.on('mouseMoved', function(e) {
        var closestHitDistance, closestHitPerson, hit, i, person, ray, _j, _len, _ref4;

        if (!_this.camera || e.handled) {
          return;
        }
        if (_this.cancelNextMouseMove) {
          _this.cancelNextMouseMove = false;
          return;
        }
        closestHitDistance = 999999999;
        closestHitPerson = null;
        ray = _this.camera.getWorldRay(e.x, e.y, _this.window.width, _this.window.height);
        _this.selectedModel = null;
        _ref4 = _this.people;
        for (i = _j = 0, _len = _ref4.length; _j < _len; i = ++_j) {
          person = _ref4[i];
          hit = rayBoxIntersection(ray, person.bbox, 1, 5000);
          if (hit > 1) {
            if (hit < closestHitDistance && (hit > 8000 || person.sourceId === -1)) {
              closestHitDistance = hit;
              closestHitPerson = person;
            }
          }
          person.selected = false;
          person.bboxHelper.setColor(Color.Red);
        }
        if (closestHitPerson) {
          closestHitPerson.bboxHelper.setColor(Color.Yellow);
          _this.selectedModel = closestHitPerson;
          return closestHitPerson.selected = true;
        }
      });
      this.window.on('mouseDragged', function(e) {
        _this.selectedModel = null;
        e.handled = true;
        if (e.preventDefault) {
          e.preventDefault();
        }
        _this.cancelNextMouseMove = true;
        if (e.handled) {

        }
      });
      this.window.on('leftMouseDown', function(e) {
        if (e.handled) {
          return;
        }
        return _this.selectedModelClick = _this.selectedModel;
      });
      this.window.on('leftMouseUp', function(e) {
        if (!_this.camera) {
          return;
        }
        if (_this.selectedModel && (_this.selectedModel.sourceId !== -1) && (_this.selectedModelClick = _this.selectedModel)) {
          return _this.window.sourceId = _this.selectedModel.sourceId;
        }
      });
    }

    PeopleCarousel.prototype.draw = function(camera) {
      var i, mesh, person, source, _i, _len, _ref4;

      this.camera = camera;
      this.gl.disable(this.gl.BLEND);
      this.gl.enable(this.gl.DEPTH_TEST);
      if (this.drawFloor) {
        this.gl.lineWidth(1);
        this.floor.draw(this.camera);
        this.gl.lineWidth(2);
        this.floorThick.draw(this.camera);
        this.gl.lineWidth(1);
      }
      mesh = this.sourcesScene.lowResMesh;
      if (!mesh) {
        return;
      }
      _ref4 = this.sourcesScene.sources;
      for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
        source = _ref4[i];
        person = this.people[i];
        if (!source) {
          continue;
        }
        mesh.source = source;
        mesh.updateChannels();
        mesh.material.uniforms.pointSize = this.pointSize;
        mesh.material.uniforms.texturedParticles = this.texturedParticles;
        mesh.material.uniforms.texture = source.imageTexture;
        mesh.material.uniforms.rotation = person.rotation;
        mesh.material.uniforms.highlight = this.selectedModel === person ? 2.0 : 0.5;
        mesh.position.setVec3(person.position);
        mesh.draw(this.camera);
      }
      mesh.position.set(0, 0, 0);
      mesh.rotation.identity();
      return mesh.material.uniforms.pointSize = 2;
    };

    PeopleCarousel.prototype.drawDebug = function(camera) {
      var helper, _i, _len, _ref4, _results;

      _ref4 = this.helpers;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        helper = _ref4[_i];
        _results.push(helper.draw(camera));
      }
      return _results;
    };

    return PeopleCarousel;

  })();
});
