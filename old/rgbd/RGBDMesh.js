// Generated by CoffeeScript 1.6.2
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(function(require) {
  var Context, Cube, Geometry, Mat4, Mesh, RGBDMesh, RGBDTExtured, Texture2D, Vec2, Vec3, Vec4, _ref, _ref1;

  _ref = require('pex/geom'), Geometry = _ref.Geometry, Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Mat4 = _ref.Mat4;
  _ref1 = require('pex/gl'), Context = _ref1.Context, Mesh = _ref1.Mesh, Texture2D = _ref1.Texture2D;
  RGBDTExtured = require('materials/RGBDTextured');
  Cube = require('pex/geom/gen').Cube;
  return RGBDMesh = (function(_super) {
    __extends(RGBDMesh, _super);

    function RGBDMesh(source, step) {
      var h, numChannels, uniforms, v, vertices, w, x, y, z, _i, _j, _k, _ref2, _ref3, _ref4;

      this.geom = new Geometry({
        vertices: true,
        faces: false
      });
      vertices = this.geom.vertices;
      this.source = source;
      w = source.depthRect.width - 1;
      h = source.depthRect.height - 1;
      step = step || 1;
      numChannels = source.channels ? source.channels.length : 1;
      for (x = _i = 0, _ref2 = w - 1; step > 0 ? _i <= _ref2 : _i >= _ref2; x = _i += step) {
        for (y = _j = 0, _ref3 = h - 1; step > 0 ? _j <= _ref3 : _j >= _ref3; y = _j += step) {
          for (z = _k = 0, _ref4 = numChannels - 1; 0 <= _ref4 ? _k <= _ref4 : _k >= _ref4; z = 0 <= _ref4 ? ++_k : --_k) {
            v = new Vec3(x, y, z);
            vertices.push(v);
          }
        }
      }
      uniforms = {
        rotation: new Mat4(),
        pointSize: 6,
        bboxMin: source.boundingBox.min,
        bboxMax: source.boundingBox.max,
        texture: source.texture,
        textureSize: source.textureSize,
        particleTexture: Texture2D.load('assets/images/particleGlow.png'),
        inputPositionRect: new Vec4(0, 0, w, h),
        depthRect: new Vec4(source.depthRect.x, source.depthRect.y, source.depthRect.width, source.depthRect.height),
        colorRect: new Vec4(source.colorRect.x, source.colorRect.y, source.colorRect.width, source.colorRect.height)
      };
      RGBDMesh.__super__.constructor.call(this, this.geom, new RGBDTExtured(uniforms), {
        primitiveType: Context.currentContext.gl
      });
      this.updateChannels();
    }

    RGBDMesh.prototype.updateChannels = function() {
      var channel, i, _i, _len, _ref2, _results;

      this.material.uniforms.texture = this.source.texture;
      this.material.uniforms.groundLevel = this.source.groundLevel;
      if (this.source.channels) {
        _ref2 = this.source.channels;
        _results = [];
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          channel = _ref2[i];
          this.material.uniforms['channelMatrix[' + i + ']'] = channel.matrix;
          this.material.uniforms['channelOffset[' + i + ']'] = channel.offset;
          this.material.uniforms['channelDepthRange[' + i + ']'] = new Vec2(channel.depthRange.min, channel.depthRange.max);
          this.material.uniforms['channelEnabled[' + i + ']'] = channel.enabled;
          this.material.uniforms['channelColor[' + i + ']'] = channel.color;
          _results.push(this.material.uniforms['channelFov[' + i + ']'] = channel.fov);
        }
        return _results;
      } else {
        this.material.uniforms['channelMatrix[0]'] = (new Mat4()).identity();
        this.material.uniforms['channelOffset[0]'] = new Vec2(0, 0);
        this.material.uniforms['channelDepthRange[0]'] = new Vec2(source.depthRange.min, source.depthRange.max);
        this.material.uniforms['channelEnabled[0]'] = true;
        return this.material.uniforms['channelFov[0]'] = source.fov;
      }
    };

    return RGBDMesh;

  })(Mesh);
});
