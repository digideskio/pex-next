// Generated by CoffeeScript 1.6.2
var Arcball, Color, Cube, Diffuse, EPSYLON, LineBuilder, MathUtils, Mesh, PerspectiveCamera, Plane, PlaneGeom, ShowColors, SolidColor, Texture2D, Vec3, hem, lerp, pex, _ref, _ref1, _ref2, _ref3, _ref4,
  _this = this;

pex = pex || require('./lib/pex');

_ref = pex.geom, Vec3 = _ref.Vec3, hem = _ref.hem, Plane = _ref.Plane;

_ref1 = pex.geom.gen, LineBuilder = _ref1.LineBuilder, Cube = _ref1.Cube;

Color = pex.color.Color;

_ref2 = pex.gl, Mesh = _ref2.Mesh, Texture2D = _ref2.Texture2D;

_ref3 = pex.materials, ShowColors = _ref3.ShowColors, SolidColor = _ref3.SolidColor, Diffuse = _ref3.Diffuse;

_ref4 = pex.scene, PerspectiveCamera = _ref4.PerspectiveCamera, Arcball = _ref4.Arcball;

MathUtils = pex.utils.MathUtils;

PlaneGeom = pex.geom.gen.Plane;

EPSYLON = 0.00001;

lerp = function(va, vb, t) {
  return Vec3.create(va.x + (vb.x - va.x) * t, va.y + (vb.y - va.y) * t, va.z + (vb.z - va.z) * t);
};

pex.require(['Plane', 'Line3d', 'pex/geom/hem/HEFace', 'GeomUtils'], function(Plane, Line3D, HEFace, GeomUtils) {
  return pex.sys.Window.create({
    settings: {
      width: 1280,
      height: 720,
      type: '3d'
    },
    debugMode: false,
    meshMode: true,
    explode: false,
    init: function() {
      var boronMaterial, geom, lineBuilder, meshes, minDist, points, _i, _results,
        _this = this;

      geom = new Cube(2, 2, 2);
      geom.computeEdges();
      lineBuilder = new LineBuilder();
      MathUtils.seed(0);
      minDist = 0.5;
      this.on('keyDown', function(e) {
        console.log(e.str, _this.debugMode);
        if (e.str === 'd') {
          _this.debugMode = !_this.debugMode;
        }
        if (e.str === 'm') {
          return _this.meshMode = !_this.meshMode;
        }
      });
      this.on('leftMouseDown', function(e) {
        return _this.explode = true;
      });
      this.on('leftMouseUp', function(e) {
        return _this.explode = false;
      });
      points = [];
      (function() {
        _results = [];
        for (_i = 0; _i <= 50; _i++){ _results.push(_i); }
        return _results;
      }).apply(this).forEach(function() {
        var farEnough, p;

        p = MathUtils.randomVec3();
        p.x *= 8;
        p.y *= 8;
        p.z *= 8;
        farEnough = true;
        points.forEach(function(anotherPoint) {});
        if (farEnough) {
          return points.push(p);
        }
      });
      console.log(points.length);
      meshes = points.map(function(center) {
        var hemesh, planes;

        if (center.length() > 1.75) {
          return null;
        }
        hemesh = hem().fromGeometry(geom);
        hemesh.vertices.forEach(function(v) {
          return v.position.add(center);
        });
        planes = points.map(function(point) {
          var centerToPoint;

          centerToPoint = Vec3.create().asSub(point, center);
          return new Plane(center.dup().add(centerToPoint.dup().scale(0.5)), centerToPoint.normalize());
        });
        planes.forEach(function(plane, planeIndex) {
          return _this.clipMesh(hemesh, plane, true);
        });
        return hemesh;
      });
      console.log(meshes.length);
      meshes = meshes.filter(function(mesh) {
        return mesh !== null;
      });
      console.log('meshes.length', meshes.length);
      meshes.forEach(function(hemesh) {
        return hemesh.faces.map(function(face, faceIndex) {
          var c, center, d, faceColor;

          c = face.getCenter();
          d = 0.05;
          center = face.getCenter();
          faceColor = face.above ? Color.Red : Color.Yellow;
          return face.edgePairLoop(function(e, ne) {
            var nv, rv, v;

            v = e.vert.position.dup().scale(1 - d).add(c.dup().scale(d));
            nv = ne.vert.position.dup().scale(1 - d).add(c.dup().scale(d));
            lineBuilder.addLine(v, nv, e.onThePlane ? Color.Green : faceColor);
            rv = e.vert.position.dup();
            rv.x += e.vert.index * 0.001;
            return lineBuilder.addCross(v, 0.03, Color.Orange);
          });
        });
      });
      boronMaterial = new Diffuse({
        wrap: 1,
        ambientColor: new Color(0.25, 0.25, 0.3, 1),
        diffuseColor: new Color(0.75, 0.75, 0.7, 1)
      });
      this.meshes = meshes.map(function(hemesh) {
        var mesh, meshCenter;

        hemesh.faces.forEach(function(face) {
          if (face.getAllVertices().length > 3) {
            return hemesh.splitFaceAtPoint(face, face.getCenter());
          }
        });
        mesh = new Mesh(hemesh.toFlatGeometry(), boronMaterial);
        mesh.position = MathUtils.randomVec3().scale(10);
        meshCenter = Vec3.create(0, 0, 0);
        hemesh.vertices.forEach(function(v) {
          return meshCenter.add(v.position);
        });
        meshCenter.scale(1 / hemesh.vertices.length * 0.01);
        mesh.position = meshCenter;
        mesh.targetPosition = meshCenter.dup().scale(100);
        mesh.originalPosition = meshCenter.dup();
        return mesh;
      });
      this.linesMesh = new Mesh(lineBuilder, new ShowColors(), {
        useEdges: true
      });
      this.camera = new PerspectiveCamera(60, this.width / this.height, 0.1, 100);
      return this.arcball = new Arcball(this, this.camera, 5);
    },
    clipMesh: function(hemesh, plane, remove, debug) {
      var edge, edgeIndex, endVert, facesToRemove, guard, newFace, newFaceEdges, newFaceEdgesSorted, numFaces, _i, _len;

      numFaces = hemesh.faces.length;
      hemesh.faces.forEach(function(face, faceIndex) {
        var hits, newEdge, splitEdge0, splitEdge1;

        debug = false;
        hits = [];
        face.edgePairLoop(function(e, ne) {
          var edgeLine, found, p;

          edgeLine = new Line3D(e.vert.position, ne.vert.position);
          p = plane.intersectSegment(edgeLine);
          if (debug) {
            if (p) {
              console.log(' ', p.toString(), p.ratio);
            }
          }
          if (p && p.ratio >= -EPSYLON && p.ratio <= 1 + EPSYLON) {
            found = false;
            hits.forEach(function(hit) {
              if (hit.point.equals(p)) {
                return found = true;
              }
            });
            if (!found) {
              return hits.push({
                edge: e,
                point: p,
                ratio: p.ratio
              });
            }
          }
        });
        if (debug) {
          console.log(' ', hits.length, 'hits', hits.map(function(v) {
            return [v.point.toString(), v.ratio];
          }));
        }
        if (hits.length === 2) {
          splitEdge0 = hits[0].edge;
          splitEdge1 = hits[1].edge;
          if (debug) {
            console.log('split between', splitEdge0.vert.position.toString(), splitEdge1.vert.position.toString());
          }
          if ((hits[0].ratio > 0 + EPSYLON) && (hits[0].ratio < 1 - EPSYLON)) {
            if (debug) {
              console.log('split 1', hits[0].ratio);
            }
            newEdge = hemesh.splitEdge(splitEdge0, hits[0].ratio);
            splitEdge0 = splitEdge0.next;
          } else if (hits[0].ratio > 1 - EPSYLON) {
            if (debug) {
              console.log('should move 1');
            }
            splitEdge0 = splitEdge0.next;
          }
          if ((hits[1].ratio > 0 + EPSYLON) && (hits[1].ratio < 1 - EPSYLON)) {
            if (debug) {
              console.log('split 2', hits[1].ratio);
            }
            hemesh.splitEdge(splitEdge1, hits[1].ratio);
            splitEdge1 = splitEdge1.next;
          } else if (hits[1].ratio > 1 - EPSYLON) {
            if (debug) {
              console.log('should move 2');
            }
            splitEdge1 = splitEdge1.next;
          }
          return hemesh.splitFace(splitEdge0, splitEdge1);
        }
      });
      facesToRemove = [];
      hemesh.fixDuplicatedVertices();
      hemesh.edges.forEach(function(e) {
        return e.onThePlane = false;
      });
      hemesh.faces.map(function(face, faceIndex) {
        var above, c, center;

        c = face.getCenter();
        center = face.getCenter();
        above = face.above = plane.isPointAbove(center);
        if (above) {
          return facesToRemove.push(face);
        }
      });
      if (debug) {
        console.log('facesToRemove.length', facesToRemove.length);
      }
      newFaceEdges = [];
      facesToRemove.forEach(function(face) {
        return face.edgePairLoop(function(e) {
          if (plane.contains(e.vert.position) && plane.contains(e.next.vert.position)) {
            e.onThePlane = true;
            return newFaceEdges.push(e);
          }
        });
      });
      hemesh.vertices.forEach(function(v, vi) {
        return v.index = vi;
      });
      if (debug) {
        console.log('newFaceEdges.length', newFaceEdges.length);
      }
      if (debug) {
        console.log(newFaceEdges.map(function(e) {
          return [e.vert.index, e.next.vert.index];
        }));
      }
      if (newFaceEdges.length === 0) {
        return;
      }
      newFaceEdgesSorted = [];
      newFaceEdgesSorted.push(newFaceEdges.shift());
      guard = 0;
      while (newFaceEdges.length > 0 && ++guard < 1000) {
        endVert = newFaceEdgesSorted[newFaceEdgesSorted.length - 1].next.vert;
        for (edgeIndex = _i = 0, _len = newFaceEdges.length; _i < _len; edgeIndex = ++_i) {
          edge = newFaceEdges[edgeIndex];
          if (endVert === edge.vert) {
            newFaceEdgesSorted.push(edge);
            newFaceEdges.splice(edgeIndex, 1);
            break;
          }
        }
      }
      if (debug) {
        console.log(newFaceEdgesSorted.map(function(e) {
          return [e.vert.index, e.next.vert.index];
        }));
      }
      if (!remove) {
        return;
      }
      newFace = new HEFace(newFaceEdgesSorted[0]);
      hemesh.faces.push(newFace);
      facesToRemove.forEach(function(face) {
        hemesh.faces.splice(hemesh.faces.indexOf(face), 1);
        return face.edgePairLoop(function(e) {
          var ei;

          if (!e.onThePlane) {
            ei = hemesh.edges.indexOf(e);
            if (ei !== -1) {
              return hemesh.edges.splice(ei, 1);
            }
          }
        });
      });
      return newFaceEdgesSorted.forEach(function(e, ei) {
        var ne;

        ne = newFaceEdgesSorted[(ei + 1) % newFaceEdgesSorted.length];
        e.next = ne;
        return e.face = newFace;
      });
    },
    draw: function() {
      var _this = this;

      this.gl.clearColor(0, 0, 0, 1);
      this.gl.clear(this.gl.DEPTH_BUFFER_BIT | this.gl.COLOR_BUFFER_BIT);
      this.gl.enable(this.gl.DEPTH_TEST);
      if (this.debugMode) {
        this.linesMesh.draw(this.camera);
      }
      if (this.meshMode) {
        return this.meshes.forEach(function(mesh) {
          if (_this.explode) {
            mesh.position = lerp(mesh.position, mesh.targetPosition, 0.2);
          } else {
            mesh.position = lerp(mesh.position, mesh.originalPosition, 0.5);
          }
          return mesh.draw(_this.camera);
        });
      }
    }
  });
});
